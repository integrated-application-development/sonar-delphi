// $ANTLR 3.5.1
// ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g 2019-08-08 15:56:12

/*
 * Sonar Delphi Plugin
 * Copyright (C) 2010 SonarSource
 * dev@sonar.codehaus.org
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
 */

package org.sonar.plugins.delphi.antlr.generated;

/** Delphi Lexer class generated by Antlr. Provides tokens. */
import org.antlr.runtime.*;

@SuppressWarnings("all")
public class DelphiLexer extends Lexer {
  public static final int EOF = -1;
  public static final int ABSOLUTE = 4;
  public static final int ABSTRACT = 5;
  public static final int ADD = 6;
  public static final int AMPERSAND = 7;
  public static final int AND = 8;
  public static final int ANSISTRING = 9;
  public static final int ARRAY = 10;
  public static final int AS = 11;
  public static final int ASM = 12;
  public static final int ASSEMBLER = 13;
  public static final int ASSEMBLY = 14;
  public static final int ASSIGN = 15;
  public static final int AT = 16;
  public static final int AT2 = 17;
  public static final int AUTOMATED = 18;
  public static final int Alpha = 19;
  public static final int BEGIN = 20;
  public static final int BREAK = 21;
  public static final int CASE = 22;
  public static final int CDECL = 23;
  public static final int CLASS = 24;
  public static final int COLON = 25;
  public static final int COMMA = 26;
  public static final int COMMENT = 27;
  public static final int CONST = 28;
  public static final int CONSTRUCTOR = 29;
  public static final int CONTAINS = 30;
  public static final int CONTINUE = 31;
  public static final int ControlString = 32;
  public static final int Controlchar = 33;
  public static final int DEFAULT = 34;
  public static final int DEPRECATED = 35;
  public static final int DESTRUCTOR = 36;
  public static final int DISPID = 37;
  public static final int DISPINTERFACE = 38;
  public static final int DIV = 39;
  public static final int DO = 40;
  public static final int DOT = 41;
  public static final int DOTDOT = 42;
  public static final int DOWNTO = 43;
  public static final int DQ = 44;
  public static final int DW = 45;
  public static final int DYNAMIC = 46;
  public static final int Digit = 47;
  public static final int Digitseq = 48;
  public static final int ELSE = 49;
  public static final int END = 50;
  public static final int EQUAL = 51;
  public static final int EXCEPT = 52;
  public static final int EXIT = 53;
  public static final int EXPERIMENTAL = 54;
  public static final int EXPORT = 55;
  public static final int EXPORTS = 56;
  public static final int EXTERNAL = 57;
  public static final int FALSE = 58;
  public static final int FAR = 59;
  public static final int FILE = 60;
  public static final int FINAL = 61;
  public static final int FINALIZATION = 62;
  public static final int FINALLY = 63;
  public static final int FOR = 64;
  public static final int FORWARD = 65;
  public static final int FUNCTION = 66;
  public static final int GE = 67;
  public static final int GOTO = 68;
  public static final int GT = 69;
  public static final int HELPER = 70;
  public static final int Hexdigit = 71;
  public static final int Hexdigitseq = 72;
  public static final int IF = 73;
  public static final int IMPLEMENTATION = 74;
  public static final int IMPLEMENTS = 75;
  public static final int IN = 76;
  public static final int INDEX = 77;
  public static final int INHERITED = 78;
  public static final int INITIALIZATION = 79;
  public static final int INLINE = 80;
  public static final int INTERFACE = 81;
  public static final int IS = 82;
  public static final int LABEL = 83;
  public static final int LBRACK = 84;
  public static final int LBRACK2 = 85;
  public static final int LCURLY = 86;
  public static final int LE = 87;
  public static final int LIBRARY = 88;
  public static final int LOCAL = 89;
  public static final int LPAREN = 90;
  public static final int LT = 91;
  public static final int MESSAGE = 92;
  public static final int MINUS = 93;
  public static final int MOD = 94;
  public static final int NAME = 95;
  public static final int NEAR = 96;
  public static final int NIL = 97;
  public static final int NODEFAULT = 98;
  public static final int NOT = 99;
  public static final int NOT_EQUAL = 100;
  public static final int OBJECT = 101;
  public static final int OF = 102;
  public static final int ON = 103;
  public static final int OPERATOR = 104;
  public static final int OR = 105;
  public static final int OUT = 106;
  public static final int OVERLOAD = 107;
  public static final int OVERRIDE = 108;
  public static final int PACKAGE = 109;
  public static final int PACKED = 110;
  public static final int PASCAL = 111;
  public static final int PLATFORM = 112;
  public static final int PLUS = 113;
  public static final int POINTER = 114;
  public static final int POINTER2 = 115;
  public static final int PRIVATE = 116;
  public static final int PROCEDURE = 117;
  public static final int PROGRAM = 118;
  public static final int PROPERTY = 119;
  public static final int PROTECTED = 120;
  public static final int PUBLIC = 121;
  public static final int PUBLISHED = 122;
  public static final int QuotedString = 123;
  public static final int RAISE = 124;
  public static final int RBRACK = 125;
  public static final int RBRACK2 = 126;
  public static final int RCURLY = 127;
  public static final int READ = 128;
  public static final int READONLY = 129;
  public static final int RECORD = 130;
  public static final int REFERENCE = 131;
  public static final int REGISTER = 132;
  public static final int REINTRODUCE = 133;
  public static final int REMOVE = 134;
  public static final int REPEAT = 135;
  public static final int REQUIRES = 136;
  public static final int RESIDENT = 137;
  public static final int RESOURCESTRING = 138;
  public static final int RPAREN = 139;
  public static final int SAFECALL = 140;
  public static final int SEALED = 141;
  public static final int SEMI = 142;
  public static final int SET = 143;
  public static final int SHL = 144;
  public static final int SHR = 145;
  public static final int SLASH = 146;
  public static final int STAR = 147;
  public static final int STATIC = 148;
  public static final int STDCALL = 149;
  public static final int STORED = 150;
  public static final int STRICT = 151;
  public static final int STRING = 152;
  public static final int THEN = 153;
  public static final int THREADVAR = 154;
  public static final int TO = 155;
  public static final int TRUE = 156;
  public static final int TRY = 157;
  public static final int TYPE = 158;
  public static final int TkAnonymousExpression = 159;
  public static final int TkAsmHexLabel = 160;
  public static final int TkAsmHexNum = 161;
  public static final int TkAssemblerInstructions = 162;
  public static final int TkBlockDeclSection = 163;
  public static final int TkClass = 164;
  public static final int TkClassField = 165;
  public static final int TkClassOfType = 166;
  public static final int TkClassParents = 167;
  public static final int TkConstantName = 168;
  public static final int TkCustomAttribute = 169;
  public static final int TkCustomAttributeArgs = 170;
  public static final int TkExceptionHandler = 171;
  public static final int TkExceptionHandlerIdent = 172;
  public static final int TkFunctionArgs = 173;
  public static final int TkFunctionBody = 174;
  public static final int TkFunctionName = 175;
  public static final int TkFunctionReturn = 176;
  public static final int TkGlobalFunction = 177;
  public static final int TkGuid = 178;
  public static final int TkHexNum = 179;
  public static final int TkIdentifier = 180;
  public static final int TkIntNum = 181;
  public static final int TkInterface = 182;
  public static final int TkNewType = 183;
  public static final int TkNewTypeDecl = 184;
  public static final int TkNewTypeName = 185;
  public static final int TkObject = 186;
  public static final int TkRealNum = 187;
  public static final int TkRecord = 188;
  public static final int TkRecordHelper = 189;
  public static final int TkVariableIdents = 190;
  public static final int TkVariableParam = 191;
  public static final int TkVariableType = 192;
  public static final int UNIT = 193;
  public static final int UNSAFE = 194;
  public static final int UNTIL = 195;
  public static final int USES = 196;
  public static final int UnicodeBOM = 197;
  public static final int VAR = 198;
  public static final int VARARGS = 199;
  public static final int VARIANT = 200;
  public static final int VIRTUAL = 201;
  public static final int WHILE = 202;
  public static final int WITH = 203;
  public static final int WRITE = 204;
  public static final int WRITEONLY = 205;
  public static final int WS = 206;
  public static final int XOR = 207;

  boolean asmMode = false;

  // delegates
  // delegators
  public Lexer[] getDelegates() {
    return new Lexer[] {};
  }

  public DelphiLexer() {}

  public DelphiLexer(CharStream input) {
    this(input, new RecognizerSharedState());
  }

  public DelphiLexer(CharStream input, RecognizerSharedState state) {
    super(input, state);
  }

  @Override
  public String getGrammarFileName() {
    return "***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g";
  }

  // $ANTLR start "ABSOLUTE"
  public final void mABSOLUTE() throws RecognitionException {
    try {
      int _type = ABSOLUTE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:760:19: ( 'absolute' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:760:21: 'absolute'
      {
        match("absolute");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "ABSOLUTE"

  // $ANTLR start "ABSTRACT"
  public final void mABSTRACT() throws RecognitionException {
    try {
      int _type = ABSTRACT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:761:19: ( 'abstract' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:761:21: 'abstract'
      {
        match("abstract");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "ABSTRACT"

  // $ANTLR start "ADD"
  public final void mADD() throws RecognitionException {
    try {
      int _type = ADD;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:762:19: ( 'add' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:762:21: 'add'
      {
        match("add");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "ADD"

  // $ANTLR start "AND"
  public final void mAND() throws RecognitionException {
    try {
      int _type = AND;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:763:19: ( 'and' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:763:21: 'and'
      {
        match("and");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "AND"

  // $ANTLR start "ANSISTRING"
  public final void mANSISTRING() throws RecognitionException {
    try {
      int _type = ANSISTRING;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:764:19: ( 'ansistring' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:764:21: 'ansistring'
      {
        match("ansistring");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "ANSISTRING"

  // $ANTLR start "ARRAY"
  public final void mARRAY() throws RecognitionException {
    try {
      int _type = ARRAY;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:765:19: ( 'array' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:765:21: 'array'
      {
        match("array");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "ARRAY"

  // $ANTLR start "AS"
  public final void mAS() throws RecognitionException {
    try {
      int _type = AS;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:766:19: ( 'as' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:766:21: 'as'
      {
        match("as");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "AS"

  // $ANTLR start "ASM"
  public final void mASM() throws RecognitionException {
    try {
      int _type = ASM;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:767:19: ( 'asm' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:767:21: 'asm'
      {
        match("asm");

        asmMode = true;
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "ASM"

  // $ANTLR start "ASSEMBLER"
  public final void mASSEMBLER() throws RecognitionException {
    try {
      int _type = ASSEMBLER;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:768:19: ( 'assembler' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:768:21: 'assembler'
      {
        match("assembler");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "ASSEMBLER"

  // $ANTLR start "ASSEMBLY"
  public final void mASSEMBLY() throws RecognitionException {
    try {
      int _type = ASSEMBLY;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:769:19: ( 'assembly' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:769:21: 'assembly'
      {
        match("assembly");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "ASSEMBLY"

  // $ANTLR start "AT"
  public final void mAT() throws RecognitionException {
    try {
      int _type = AT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:770:19: ( 'at' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:770:21: 'at'
      {
        match("at");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "AT"

  // $ANTLR start "AUTOMATED"
  public final void mAUTOMATED() throws RecognitionException {
    try {
      int _type = AUTOMATED;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:771:19: ( 'automated' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:771:21: 'automated'
      {
        match("automated");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "AUTOMATED"

  // $ANTLR start "BEGIN"
  public final void mBEGIN() throws RecognitionException {
    try {
      int _type = BEGIN;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:772:19: ( 'begin' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:772:21: 'begin'
      {
        match("begin");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "BEGIN"

  // $ANTLR start "BREAK"
  public final void mBREAK() throws RecognitionException {
    try {
      int _type = BREAK;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:773:19: ( 'break' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:773:21: 'break'
      {
        match("break");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "BREAK"

  // $ANTLR start "CASE"
  public final void mCASE() throws RecognitionException {
    try {
      int _type = CASE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:774:19: ( 'case' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:774:21: 'case'
      {
        match("case");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "CASE"

  // $ANTLR start "CDECL"
  public final void mCDECL() throws RecognitionException {
    try {
      int _type = CDECL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:775:19: ( 'cdecl' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:775:21: 'cdecl'
      {
        match("cdecl");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "CDECL"

  // $ANTLR start "CLASS"
  public final void mCLASS() throws RecognitionException {
    try {
      int _type = CLASS;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:776:19: ( 'class' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:776:21: 'class'
      {
        match("class");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "CLASS"

  // $ANTLR start "CONST"
  public final void mCONST() throws RecognitionException {
    try {
      int _type = CONST;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:777:19: ( 'const' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:777:21: 'const'
      {
        match("const");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "CONST"

  // $ANTLR start "CONSTRUCTOR"
  public final void mCONSTRUCTOR() throws RecognitionException {
    try {
      int _type = CONSTRUCTOR;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:778:19: ( 'constructor' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:778:21: 'constructor'
      {
        match("constructor");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "CONSTRUCTOR"

  // $ANTLR start "CONTAINS"
  public final void mCONTAINS() throws RecognitionException {
    try {
      int _type = CONTAINS;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:779:19: ( 'contains' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:779:21: 'contains'
      {
        match("contains");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "CONTAINS"

  // $ANTLR start "CONTINUE"
  public final void mCONTINUE() throws RecognitionException {
    try {
      int _type = CONTINUE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:780:19: ( 'continue' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:780:21: 'continue'
      {
        match("continue");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "CONTINUE"

  // $ANTLR start "DEFAULT"
  public final void mDEFAULT() throws RecognitionException {
    try {
      int _type = DEFAULT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:781:19: ( 'default' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:781:21: 'default'
      {
        match("default");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "DEFAULT"

  // $ANTLR start "DEPRECATED"
  public final void mDEPRECATED() throws RecognitionException {
    try {
      int _type = DEPRECATED;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:782:19: ( 'deprecated' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:782:21: 'deprecated'
      {
        match("deprecated");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "DEPRECATED"

  // $ANTLR start "DESTRUCTOR"
  public final void mDESTRUCTOR() throws RecognitionException {
    try {
      int _type = DESTRUCTOR;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:783:19: ( 'destructor' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:783:21: 'destructor'
      {
        match("destructor");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "DESTRUCTOR"

  // $ANTLR start "DISPID"
  public final void mDISPID() throws RecognitionException {
    try {
      int _type = DISPID;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:784:19: ( 'dispid' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:784:21: 'dispid'
      {
        match("dispid");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "DISPID"

  // $ANTLR start "DISPINTERFACE"
  public final void mDISPINTERFACE() throws RecognitionException {
    try {
      int _type = DISPINTERFACE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:785:19: ( 'dispinterface' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:785:21: 'dispinterface'
      {
        match("dispinterface");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "DISPINTERFACE"

  // $ANTLR start "DIV"
  public final void mDIV() throws RecognitionException {
    try {
      int _type = DIV;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:786:19: ( 'div' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:786:21: 'div'
      {
        match("div");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "DIV"

  // $ANTLR start "DO"
  public final void mDO() throws RecognitionException {
    try {
      int _type = DO;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:787:19: ( 'do' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:787:21: 'do'
      {
        match("do");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "DO"

  // $ANTLR start "DOWNTO"
  public final void mDOWNTO() throws RecognitionException {
    try {
      int _type = DOWNTO;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:788:19: ( 'downto' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:788:21: 'downto'
      {
        match("downto");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "DOWNTO"

  // $ANTLR start "DQ"
  public final void mDQ() throws RecognitionException {
    try {
      int _type = DQ;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:789:19: ( 'dq' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:789:21: 'dq'
      {
        match("dq");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "DQ"

  // $ANTLR start "DW"
  public final void mDW() throws RecognitionException {
    try {
      int _type = DW;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:790:19: ( 'dw' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:790:21: 'dw'
      {
        match("dw");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "DW"

  // $ANTLR start "DYNAMIC"
  public final void mDYNAMIC() throws RecognitionException {
    try {
      int _type = DYNAMIC;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:791:19: ( 'dynamic' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:791:21: 'dynamic'
      {
        match("dynamic");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "DYNAMIC"

  // $ANTLR start "ELSE"
  public final void mELSE() throws RecognitionException {
    try {
      int _type = ELSE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:792:19: ( 'else' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:792:21: 'else'
      {
        match("else");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "ELSE"

  // $ANTLR start "END"
  public final void mEND() throws RecognitionException {
    try {
      int _type = END;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:793:19: ( 'end' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:793:21: 'end'
      {
        match("end");

        asmMode = false;
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "END"

  // $ANTLR start "EXCEPT"
  public final void mEXCEPT() throws RecognitionException {
    try {
      int _type = EXCEPT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:794:19: ( 'except' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:794:21: 'except'
      {
        match("except");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "EXCEPT"

  // $ANTLR start "EXIT"
  public final void mEXIT() throws RecognitionException {
    try {
      int _type = EXIT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:795:19: ( 'exit' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:795:21: 'exit'
      {
        match("exit");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "EXIT"

  // $ANTLR start "EXPERIMENTAL"
  public final void mEXPERIMENTAL() throws RecognitionException {
    try {
      int _type = EXPERIMENTAL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:796:19: ( 'experimental' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:796:21: 'experimental'
      {
        match("experimental");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "EXPERIMENTAL"

  // $ANTLR start "EXPORT"
  public final void mEXPORT() throws RecognitionException {
    try {
      int _type = EXPORT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:797:19: ( 'export' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:797:21: 'export'
      {
        match("export");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "EXPORT"

  // $ANTLR start "EXPORTS"
  public final void mEXPORTS() throws RecognitionException {
    try {
      int _type = EXPORTS;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:798:19: ( 'exports' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:798:21: 'exports'
      {
        match("exports");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "EXPORTS"

  // $ANTLR start "EXTERNAL"
  public final void mEXTERNAL() throws RecognitionException {
    try {
      int _type = EXTERNAL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:799:19: ( 'external' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:799:21: 'external'
      {
        match("external");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "EXTERNAL"

  // $ANTLR start "FAR"
  public final void mFAR() throws RecognitionException {
    try {
      int _type = FAR;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:800:19: ( 'far' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:800:21: 'far'
      {
        match("far");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "FAR"

  // $ANTLR start "FILE"
  public final void mFILE() throws RecognitionException {
    try {
      int _type = FILE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:801:19: ( 'file' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:801:21: 'file'
      {
        match("file");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "FILE"

  // $ANTLR start "FINAL"
  public final void mFINAL() throws RecognitionException {
    try {
      int _type = FINAL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:802:19: ( 'final' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:802:21: 'final'
      {
        match("final");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "FINAL"

  // $ANTLR start "FINALIZATION"
  public final void mFINALIZATION() throws RecognitionException {
    try {
      int _type = FINALIZATION;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:803:19: ( 'finalization' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:803:21: 'finalization'
      {
        match("finalization");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "FINALIZATION"

  // $ANTLR start "FINALLY"
  public final void mFINALLY() throws RecognitionException {
    try {
      int _type = FINALLY;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:804:19: ( 'finally' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:804:21: 'finally'
      {
        match("finally");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "FINALLY"

  // $ANTLR start "FOR"
  public final void mFOR() throws RecognitionException {
    try {
      int _type = FOR;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:805:19: ( 'for' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:805:21: 'for'
      {
        match("for");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "FOR"

  // $ANTLR start "FORWARD"
  public final void mFORWARD() throws RecognitionException {
    try {
      int _type = FORWARD;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:806:19: ( 'forward' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:806:21: 'forward'
      {
        match("forward");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "FORWARD"

  // $ANTLR start "FUNCTION"
  public final void mFUNCTION() throws RecognitionException {
    try {
      int _type = FUNCTION;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:807:19: ( 'function' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:807:21: 'function'
      {
        match("function");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "FUNCTION"

  // $ANTLR start "GOTO"
  public final void mGOTO() throws RecognitionException {
    try {
      int _type = GOTO;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:808:19: ( 'goto' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:808:21: 'goto'
      {
        match("goto");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "GOTO"

  // $ANTLR start "HELPER"
  public final void mHELPER() throws RecognitionException {
    try {
      int _type = HELPER;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:809:19: ( 'helper' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:809:21: 'helper'
      {
        match("helper");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "HELPER"

  // $ANTLR start "IF"
  public final void mIF() throws RecognitionException {
    try {
      int _type = IF;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:810:19: ( 'if' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:810:21: 'if'
      {
        match("if");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "IF"

  // $ANTLR start "IMPLEMENTATION"
  public final void mIMPLEMENTATION() throws RecognitionException {
    try {
      int _type = IMPLEMENTATION;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:811:19: ( 'implementation' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:811:21: 'implementation'
      {
        match("implementation");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "IMPLEMENTATION"

  // $ANTLR start "IMPLEMENTS"
  public final void mIMPLEMENTS() throws RecognitionException {
    try {
      int _type = IMPLEMENTS;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:812:19: ( 'implements' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:812:21: 'implements'
      {
        match("implements");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "IMPLEMENTS"

  // $ANTLR start "IN"
  public final void mIN() throws RecognitionException {
    try {
      int _type = IN;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:813:19: ( 'in' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:813:21: 'in'
      {
        match("in");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "IN"

  // $ANTLR start "INDEX"
  public final void mINDEX() throws RecognitionException {
    try {
      int _type = INDEX;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:814:19: ( 'index' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:814:21: 'index'
      {
        match("index");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "INDEX"

  // $ANTLR start "INHERITED"
  public final void mINHERITED() throws RecognitionException {
    try {
      int _type = INHERITED;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:815:19: ( 'inherited' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:815:21: 'inherited'
      {
        match("inherited");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "INHERITED"

  // $ANTLR start "INITIALIZATION"
  public final void mINITIALIZATION() throws RecognitionException {
    try {
      int _type = INITIALIZATION;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:816:19: ( 'initialization' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:816:21: 'initialization'
      {
        match("initialization");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "INITIALIZATION"

  // $ANTLR start "INLINE"
  public final void mINLINE() throws RecognitionException {
    try {
      int _type = INLINE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:817:19: ( 'inline' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:817:21: 'inline'
      {
        match("inline");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "INLINE"

  // $ANTLR start "INTERFACE"
  public final void mINTERFACE() throws RecognitionException {
    try {
      int _type = INTERFACE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:818:19: ( 'interface' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:818:21: 'interface'
      {
        match("interface");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "INTERFACE"

  // $ANTLR start "IS"
  public final void mIS() throws RecognitionException {
    try {
      int _type = IS;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:819:19: ( 'is' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:819:21: 'is'
      {
        match("is");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "IS"

  // $ANTLR start "LABEL"
  public final void mLABEL() throws RecognitionException {
    try {
      int _type = LABEL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:820:19: ( 'label' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:820:21: 'label'
      {
        match("label");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "LABEL"

  // $ANTLR start "LIBRARY"
  public final void mLIBRARY() throws RecognitionException {
    try {
      int _type = LIBRARY;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:821:19: ( 'library' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:821:21: 'library'
      {
        match("library");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "LIBRARY"

  // $ANTLR start "LOCAL"
  public final void mLOCAL() throws RecognitionException {
    try {
      int _type = LOCAL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:822:19: ( 'local' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:822:21: 'local'
      {
        match("local");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "LOCAL"

  // $ANTLR start "MESSAGE"
  public final void mMESSAGE() throws RecognitionException {
    try {
      int _type = MESSAGE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:823:19: ( 'message' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:823:21: 'message'
      {
        match("message");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "MESSAGE"

  // $ANTLR start "MOD"
  public final void mMOD() throws RecognitionException {
    try {
      int _type = MOD;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:824:19: ( 'mod' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:824:21: 'mod'
      {
        match("mod");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "MOD"

  // $ANTLR start "NAME"
  public final void mNAME() throws RecognitionException {
    try {
      int _type = NAME;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:825:19: ( 'name' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:825:21: 'name'
      {
        match("name");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "NAME"

  // $ANTLR start "NEAR"
  public final void mNEAR() throws RecognitionException {
    try {
      int _type = NEAR;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:826:19: ( 'near' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:826:21: 'near'
      {
        match("near");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "NEAR"

  // $ANTLR start "NIL"
  public final void mNIL() throws RecognitionException {
    try {
      int _type = NIL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:827:19: ( 'nil' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:827:21: 'nil'
      {
        match("nil");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "NIL"

  // $ANTLR start "NODEFAULT"
  public final void mNODEFAULT() throws RecognitionException {
    try {
      int _type = NODEFAULT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:828:19: ( 'nodefault' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:828:21: 'nodefault'
      {
        match("nodefault");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "NODEFAULT"

  // $ANTLR start "NOT"
  public final void mNOT() throws RecognitionException {
    try {
      int _type = NOT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:829:19: ( 'not' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:829:21: 'not'
      {
        match("not");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "NOT"

  // $ANTLR start "OBJECT"
  public final void mOBJECT() throws RecognitionException {
    try {
      int _type = OBJECT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:830:19: ( 'object' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:830:21: 'object'
      {
        match("object");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "OBJECT"

  // $ANTLR start "OF"
  public final void mOF() throws RecognitionException {
    try {
      int _type = OF;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:831:19: ( 'of' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:831:21: 'of'
      {
        match("of");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "OF"

  // $ANTLR start "ON"
  public final void mON() throws RecognitionException {
    try {
      int _type = ON;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:832:19: ( 'on' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:832:21: 'on'
      {
        match("on");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "ON"

  // $ANTLR start "OPERATOR"
  public final void mOPERATOR() throws RecognitionException {
    try {
      int _type = OPERATOR;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:833:19: ( 'operator' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:833:21: 'operator'
      {
        match("operator");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "OPERATOR"

  // $ANTLR start "OR"
  public final void mOR() throws RecognitionException {
    try {
      int _type = OR;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:834:19: ( 'or' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:834:21: 'or'
      {
        match("or");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "OR"

  // $ANTLR start "OUT"
  public final void mOUT() throws RecognitionException {
    try {
      int _type = OUT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:835:19: ( 'out' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:835:21: 'out'
      {
        match("out");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "OUT"

  // $ANTLR start "OVERLOAD"
  public final void mOVERLOAD() throws RecognitionException {
    try {
      int _type = OVERLOAD;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:836:19: ( 'overload' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:836:21: 'overload'
      {
        match("overload");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "OVERLOAD"

  // $ANTLR start "OVERRIDE"
  public final void mOVERRIDE() throws RecognitionException {
    try {
      int _type = OVERRIDE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:837:19: ( 'override' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:837:21: 'override'
      {
        match("override");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "OVERRIDE"

  // $ANTLR start "PACKAGE"
  public final void mPACKAGE() throws RecognitionException {
    try {
      int _type = PACKAGE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:838:19: ( 'package' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:838:21: 'package'
      {
        match("package");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "PACKAGE"

  // $ANTLR start "PACKED"
  public final void mPACKED() throws RecognitionException {
    try {
      int _type = PACKED;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:839:19: ( 'packed' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:839:21: 'packed'
      {
        match("packed");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "PACKED"

  // $ANTLR start "PASCAL"
  public final void mPASCAL() throws RecognitionException {
    try {
      int _type = PASCAL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:840:19: ( 'pascal' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:840:21: 'pascal'
      {
        match("pascal");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "PASCAL"

  // $ANTLR start "PLATFORM"
  public final void mPLATFORM() throws RecognitionException {
    try {
      int _type = PLATFORM;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:841:19: ( 'platform' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:841:21: 'platform'
      {
        match("platform");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "PLATFORM"

  // $ANTLR start "POINTER"
  public final void mPOINTER() throws RecognitionException {
    try {
      int _type = POINTER;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:842:19: ( 'pointer' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:842:21: 'pointer'
      {
        match("pointer");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "POINTER"

  // $ANTLR start "PRIVATE"
  public final void mPRIVATE() throws RecognitionException {
    try {
      int _type = PRIVATE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:843:19: ( 'private' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:843:21: 'private'
      {
        match("private");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "PRIVATE"

  // $ANTLR start "PROCEDURE"
  public final void mPROCEDURE() throws RecognitionException {
    try {
      int _type = PROCEDURE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:844:19: ( 'procedure' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:844:21: 'procedure'
      {
        match("procedure");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "PROCEDURE"

  // $ANTLR start "PROGRAM"
  public final void mPROGRAM() throws RecognitionException {
    try {
      int _type = PROGRAM;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:845:19: ( 'program' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:845:21: 'program'
      {
        match("program");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "PROGRAM"

  // $ANTLR start "PROPERTY"
  public final void mPROPERTY() throws RecognitionException {
    try {
      int _type = PROPERTY;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:846:19: ( 'property' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:846:21: 'property'
      {
        match("property");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "PROPERTY"

  // $ANTLR start "PROTECTED"
  public final void mPROTECTED() throws RecognitionException {
    try {
      int _type = PROTECTED;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:847:19: ( 'protected' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:847:21: 'protected'
      {
        match("protected");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "PROTECTED"

  // $ANTLR start "PUBLIC"
  public final void mPUBLIC() throws RecognitionException {
    try {
      int _type = PUBLIC;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:848:19: ( 'public' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:848:21: 'public'
      {
        match("public");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "PUBLIC"

  // $ANTLR start "PUBLISHED"
  public final void mPUBLISHED() throws RecognitionException {
    try {
      int _type = PUBLISHED;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:849:19: ( 'published' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:849:21: 'published'
      {
        match("published");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "PUBLISHED"

  // $ANTLR start "RAISE"
  public final void mRAISE() throws RecognitionException {
    try {
      int _type = RAISE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:850:19: ( 'raise' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:850:21: 'raise'
      {
        match("raise");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "RAISE"

  // $ANTLR start "READ"
  public final void mREAD() throws RecognitionException {
    try {
      int _type = READ;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:851:19: ( 'read' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:851:21: 'read'
      {
        match("read");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "READ"

  // $ANTLR start "READONLY"
  public final void mREADONLY() throws RecognitionException {
    try {
      int _type = READONLY;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:852:19: ( 'readonly' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:852:21: 'readonly'
      {
        match("readonly");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "READONLY"

  // $ANTLR start "RECORD"
  public final void mRECORD() throws RecognitionException {
    try {
      int _type = RECORD;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:853:19: ( 'record' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:853:21: 'record'
      {
        match("record");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "RECORD"

  // $ANTLR start "REFERENCE"
  public final void mREFERENCE() throws RecognitionException {
    try {
      int _type = REFERENCE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:854:19: ( 'reference' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:854:21: 'reference'
      {
        match("reference");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "REFERENCE"

  // $ANTLR start "REGISTER"
  public final void mREGISTER() throws RecognitionException {
    try {
      int _type = REGISTER;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:855:19: ( 'register' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:855:21: 'register'
      {
        match("register");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "REGISTER"

  // $ANTLR start "REINTRODUCE"
  public final void mREINTRODUCE() throws RecognitionException {
    try {
      int _type = REINTRODUCE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:856:19: ( 'reintroduce' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:856:21: 'reintroduce'
      {
        match("reintroduce");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "REINTRODUCE"

  // $ANTLR start "REMOVE"
  public final void mREMOVE() throws RecognitionException {
    try {
      int _type = REMOVE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:857:19: ( 'remove' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:857:21: 'remove'
      {
        match("remove");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "REMOVE"

  // $ANTLR start "REPEAT"
  public final void mREPEAT() throws RecognitionException {
    try {
      int _type = REPEAT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:858:19: ( 'repeat' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:858:21: 'repeat'
      {
        match("repeat");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "REPEAT"

  // $ANTLR start "REQUIRES"
  public final void mREQUIRES() throws RecognitionException {
    try {
      int _type = REQUIRES;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:859:19: ( 'requires' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:859:21: 'requires'
      {
        match("requires");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "REQUIRES"

  // $ANTLR start "RESIDENT"
  public final void mRESIDENT() throws RecognitionException {
    try {
      int _type = RESIDENT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:860:19: ( 'resident' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:860:21: 'resident'
      {
        match("resident");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "RESIDENT"

  // $ANTLR start "RESOURCESTRING"
  public final void mRESOURCESTRING() throws RecognitionException {
    try {
      int _type = RESOURCESTRING;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:861:19: ( 'resourcestring' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:861:21: 'resourcestring'
      {
        match("resourcestring");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "RESOURCESTRING"

  // $ANTLR start "SAFECALL"
  public final void mSAFECALL() throws RecognitionException {
    try {
      int _type = SAFECALL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:862:19: ( 'safecall' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:862:21: 'safecall'
      {
        match("safecall");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "SAFECALL"

  // $ANTLR start "SEALED"
  public final void mSEALED() throws RecognitionException {
    try {
      int _type = SEALED;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:863:19: ( 'sealed' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:863:21: 'sealed'
      {
        match("sealed");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "SEALED"

  // $ANTLR start "SET"
  public final void mSET() throws RecognitionException {
    try {
      int _type = SET;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:864:19: ( 'set' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:864:21: 'set'
      {
        match("set");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "SET"

  // $ANTLR start "SHL"
  public final void mSHL() throws RecognitionException {
    try {
      int _type = SHL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:865:19: ( 'shl' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:865:21: 'shl'
      {
        match("shl");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "SHL"

  // $ANTLR start "SHR"
  public final void mSHR() throws RecognitionException {
    try {
      int _type = SHR;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:866:19: ( 'shr' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:866:21: 'shr'
      {
        match("shr");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "SHR"

  // $ANTLR start "STATIC"
  public final void mSTATIC() throws RecognitionException {
    try {
      int _type = STATIC;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:867:19: ( 'static' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:867:21: 'static'
      {
        match("static");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "STATIC"

  // $ANTLR start "STDCALL"
  public final void mSTDCALL() throws RecognitionException {
    try {
      int _type = STDCALL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:868:19: ( 'stdcall' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:868:21: 'stdcall'
      {
        match("stdcall");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "STDCALL"

  // $ANTLR start "STORED"
  public final void mSTORED() throws RecognitionException {
    try {
      int _type = STORED;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:869:19: ( 'stored' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:869:21: 'stored'
      {
        match("stored");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "STORED"

  // $ANTLR start "STRICT"
  public final void mSTRICT() throws RecognitionException {
    try {
      int _type = STRICT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:870:19: ( 'strict' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:870:21: 'strict'
      {
        match("strict");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "STRICT"

  // $ANTLR start "STRING"
  public final void mSTRING() throws RecognitionException {
    try {
      int _type = STRING;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:871:19: ( 'string' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:871:21: 'string'
      {
        match("string");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "STRING"

  // $ANTLR start "THEN"
  public final void mTHEN() throws RecognitionException {
    try {
      int _type = THEN;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:872:19: ( 'then' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:872:21: 'then'
      {
        match("then");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "THEN"

  // $ANTLR start "THREADVAR"
  public final void mTHREADVAR() throws RecognitionException {
    try {
      int _type = THREADVAR;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:873:19: ( 'threadvar' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:873:21: 'threadvar'
      {
        match("threadvar");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "THREADVAR"

  // $ANTLR start "TO"
  public final void mTO() throws RecognitionException {
    try {
      int _type = TO;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:874:19: ( 'to' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:874:21: 'to'
      {
        match("to");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TO"

  // $ANTLR start "TRY"
  public final void mTRY() throws RecognitionException {
    try {
      int _type = TRY;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:875:19: ( 'try' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:875:21: 'try'
      {
        match("try");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TRY"

  // $ANTLR start "TYPE"
  public final void mTYPE() throws RecognitionException {
    try {
      int _type = TYPE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:876:19: ( 'type' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:876:21: 'type'
      {
        match("type");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TYPE"

  // $ANTLR start "UNIT"
  public final void mUNIT() throws RecognitionException {
    try {
      int _type = UNIT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:877:19: ( 'unit' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:877:21: 'unit'
      {
        match("unit");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "UNIT"

  // $ANTLR start "UNSAFE"
  public final void mUNSAFE() throws RecognitionException {
    try {
      int _type = UNSAFE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:878:19: ( 'unsafe' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:878:21: 'unsafe'
      {
        match("unsafe");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "UNSAFE"

  // $ANTLR start "UNTIL"
  public final void mUNTIL() throws RecognitionException {
    try {
      int _type = UNTIL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:879:19: ( 'until' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:879:21: 'until'
      {
        match("until");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "UNTIL"

  // $ANTLR start "USES"
  public final void mUSES() throws RecognitionException {
    try {
      int _type = USES;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:880:19: ( 'uses' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:880:21: 'uses'
      {
        match("uses");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "USES"

  // $ANTLR start "VAR"
  public final void mVAR() throws RecognitionException {
    try {
      int _type = VAR;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:881:19: ( 'var' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:881:21: 'var'
      {
        match("var");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "VAR"

  // $ANTLR start "VARARGS"
  public final void mVARARGS() throws RecognitionException {
    try {
      int _type = VARARGS;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:882:19: ( 'varargs' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:882:21: 'varargs'
      {
        match("varargs");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "VARARGS"

  // $ANTLR start "VARIANT"
  public final void mVARIANT() throws RecognitionException {
    try {
      int _type = VARIANT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:883:19: ( 'variant' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:883:21: 'variant'
      {
        match("variant");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "VARIANT"

  // $ANTLR start "VIRTUAL"
  public final void mVIRTUAL() throws RecognitionException {
    try {
      int _type = VIRTUAL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:884:19: ( 'virtual' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:884:21: 'virtual'
      {
        match("virtual");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "VIRTUAL"

  // $ANTLR start "WHILE"
  public final void mWHILE() throws RecognitionException {
    try {
      int _type = WHILE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:885:19: ( 'while' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:885:21: 'while'
      {
        match("while");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "WHILE"

  // $ANTLR start "WITH"
  public final void mWITH() throws RecognitionException {
    try {
      int _type = WITH;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:886:19: ( 'with' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:886:21: 'with'
      {
        match("with");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "WITH"

  // $ANTLR start "WRITE"
  public final void mWRITE() throws RecognitionException {
    try {
      int _type = WRITE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:887:19: ( 'write' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:887:21: 'write'
      {
        match("write");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "WRITE"

  // $ANTLR start "WRITEONLY"
  public final void mWRITEONLY() throws RecognitionException {
    try {
      int _type = WRITEONLY;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:888:19: ( 'writeonly' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:888:21: 'writeonly'
      {
        match("writeonly");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "WRITEONLY"

  // $ANTLR start "XOR"
  public final void mXOR() throws RecognitionException {
    try {
      int _type = XOR;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:889:19: ( 'xor' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:889:21: 'xor'
      {
        match("xor");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "XOR"

  // $ANTLR start "FALSE"
  public final void mFALSE() throws RecognitionException {
    try {
      int _type = FALSE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:890:19: ( 'false' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:890:21: 'false'
      {
        match("false");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "FALSE"

  // $ANTLR start "TRUE"
  public final void mTRUE() throws RecognitionException {
    try {
      int _type = TRUE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:891:19: ( 'true' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:891:21: 'true'
      {
        match("true");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TRUE"

  // $ANTLR start "PLUS"
  public final void mPLUS() throws RecognitionException {
    try {
      int _type = PLUS;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:896:19: ( '+' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:896:21: '+'
      {
        match('+');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "PLUS"

  // $ANTLR start "MINUS"
  public final void mMINUS() throws RecognitionException {
    try {
      int _type = MINUS;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:897:19: ( '-' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:897:21: '-'
      {
        match('-');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "MINUS"

  // $ANTLR start "STAR"
  public final void mSTAR() throws RecognitionException {
    try {
      int _type = STAR;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:898:19: ( '*' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:898:21: '*'
      {
        match('*');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "STAR"

  // $ANTLR start "SLASH"
  public final void mSLASH() throws RecognitionException {
    try {
      int _type = SLASH;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:899:19: ( '/' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:899:21: '/'
      {
        match('/');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "SLASH"

  // $ANTLR start "ASSIGN"
  public final void mASSIGN() throws RecognitionException {
    try {
      int _type = ASSIGN;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:900:19: ( ':=' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:900:21: ':='
      {
        match(":=");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "ASSIGN"

  // $ANTLR start "COMMA"
  public final void mCOMMA() throws RecognitionException {
    try {
      int _type = COMMA;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:901:19: ( ',' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:901:21: ','
      {
        match(',');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "COMMA"

  // $ANTLR start "SEMI"
  public final void mSEMI() throws RecognitionException {
    try {
      int _type = SEMI;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:902:19: ( ';' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:902:21: ';'
      {
        match(';');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "SEMI"

  // $ANTLR start "COLON"
  public final void mCOLON() throws RecognitionException {
    try {
      int _type = COLON;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:903:19: ( ':' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:903:21: ':'
      {
        match(':');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "COLON"

  // $ANTLR start "EQUAL"
  public final void mEQUAL() throws RecognitionException {
    try {
      int _type = EQUAL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:904:19: ( '=' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:904:21: '='
      {
        match('=');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "EQUAL"

  // $ANTLR start "NOT_EQUAL"
  public final void mNOT_EQUAL() throws RecognitionException {
    try {
      int _type = NOT_EQUAL;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:905:19: ( '<>' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:905:21: '<>'
      {
        match("<>");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "NOT_EQUAL"

  // $ANTLR start "LT"
  public final void mLT() throws RecognitionException {
    try {
      int _type = LT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:906:19: ( '<' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:906:21: '<'
      {
        match('<');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "LT"

  // $ANTLR start "LE"
  public final void mLE() throws RecognitionException {
    try {
      int _type = LE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:907:19: ( '<=' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:907:21: '<='
      {
        match("<=");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "LE"

  // $ANTLR start "GE"
  public final void mGE() throws RecognitionException {
    try {
      int _type = GE;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:908:19: ( '>=' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:908:21: '>='
      {
        match(">=");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "GE"

  // $ANTLR start "GT"
  public final void mGT() throws RecognitionException {
    try {
      int _type = GT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:909:19: ( '>' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:909:21: '>'
      {
        match('>');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "GT"

  // $ANTLR start "LPAREN"
  public final void mLPAREN() throws RecognitionException {
    try {
      int _type = LPAREN;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:910:19: ( '(' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:910:21: '('
      {
        match('(');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "LPAREN"

  // $ANTLR start "RPAREN"
  public final void mRPAREN() throws RecognitionException {
    try {
      int _type = RPAREN;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:911:19: ( ')' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:911:21: ')'
      {
        match(')');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "RPAREN"

  // $ANTLR start "LBRACK"
  public final void mLBRACK() throws RecognitionException {
    try {
      int _type = LBRACK;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:912:19: ( '[' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:912:21: '['
      {
        match('[');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "LBRACK"

  // $ANTLR start "LBRACK2"
  public final void mLBRACK2() throws RecognitionException {
    try {
      int _type = LBRACK2;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:913:19: ( '(.' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:913:21: '(.'
      {
        match("(.");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "LBRACK2"

  // $ANTLR start "RBRACK"
  public final void mRBRACK() throws RecognitionException {
    try {
      int _type = RBRACK;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:914:19: ( ']' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:914:21: ']'
      {
        match(']');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "RBRACK"

  // $ANTLR start "RBRACK2"
  public final void mRBRACK2() throws RecognitionException {
    try {
      int _type = RBRACK2;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:915:19: ( '.)' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:915:21: '.)'
      {
        match(".)");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "RBRACK2"

  // $ANTLR start "POINTER2"
  public final void mPOINTER2() throws RecognitionException {
    try {
      int _type = POINTER2;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:916:19: ( '^' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:916:21: '^'
      {
        match('^');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "POINTER2"

  // $ANTLR start "AT2"
  public final void mAT2() throws RecognitionException {
    try {
      int _type = AT2;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:917:19: ( '@' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:917:21: '@'
      {
        match('@');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "AT2"

  // $ANTLR start "DOT"
  public final void mDOT() throws RecognitionException {
    try {
      int _type = DOT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:918:19: ( '.' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:918:21: '.'
      {
        match('.');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "DOT"

  // $ANTLR start "DOTDOT"
  public final void mDOTDOT() throws RecognitionException {
    try {
      int _type = DOTDOT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:919:19: ( '..' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:919:21: '..'
      {
        match("..");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "DOTDOT"

  // $ANTLR start "LCURLY"
  public final void mLCURLY() throws RecognitionException {
    try {
      int _type = LCURLY;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:920:19: ( '{' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:920:21: '{'
      {
        match('{');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "LCURLY"

  // $ANTLR start "RCURLY"
  public final void mRCURLY() throws RecognitionException {
    try {
      int _type = RCURLY;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:921:19: ( '}' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:921:21: '}'
      {
        match('}');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "RCURLY"

  // $ANTLR start "AMPERSAND"
  public final void mAMPERSAND() throws RecognitionException {
    try {
      int _type = AMPERSAND;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:922:19: ( '&' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:922:21: '&'
      {
        match('&');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "AMPERSAND"

  // $ANTLR start "TkGlobalFunction"
  public final void mTkGlobalFunction() throws RecognitionException {
    try {
      int _type = TkGlobalFunction;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:927:25: ( 'FUNCTION_GLOBAL' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:927:27: 'FUNCTION_GLOBAL'
      {
        match("FUNCTION_GLOBAL");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkGlobalFunction"

  // $ANTLR start "TkFunctionName"
  public final void mTkFunctionName() throws RecognitionException {
    try {
      int _type = TkFunctionName;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:929:25: ( 'FUNCTION_NAME' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:929:27: 'FUNCTION_NAME'
      {
        match("FUNCTION_NAME");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkFunctionName"

  // $ANTLR start "TkConstantName"
  public final void mTkConstantName() throws RecognitionException {
    try {
      int _type = TkConstantName;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:931:25: ( 'CONSTANT_NAME' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:931:27: 'CONSTANT_NAME'
      {
        match("CONSTANT_NAME");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkConstantName"

  // $ANTLR start "TkFunctionArgs"
  public final void mTkFunctionArgs() throws RecognitionException {
    try {
      int _type = TkFunctionArgs;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:933:25: ( 'FUNCTION_ARGS' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:933:27: 'FUNCTION_ARGS'
      {
        match("FUNCTION_ARGS");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkFunctionArgs"

  // $ANTLR start "TkFunctionBody"
  public final void mTkFunctionBody() throws RecognitionException {
    try {
      int _type = TkFunctionBody;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:935:25: ( 'FUNCTION_BODY' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:935:27: 'FUNCTION_BODY'
      {
        match("FUNCTION_BODY");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkFunctionBody"

  // $ANTLR start "TkFunctionReturn"
  public final void mTkFunctionReturn() throws RecognitionException {
    try {
      int _type = TkFunctionReturn;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:937:25: ( 'FUNCTION_RETURN' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:937:27: 'FUNCTION_RETURN'
      {
        match("FUNCTION_RETURN");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkFunctionReturn"

  // $ANTLR start "TkCustomAttribute"
  public final void mTkCustomAttribute() throws RecognitionException {
    try {
      int _type = TkCustomAttribute;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:939:25: ( 'CUSTOM_ATTRIBUTE' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:939:27: 'CUSTOM_ATTRIBUTE'
      {
        match("CUSTOM_ATTRIBUTE");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkCustomAttribute"

  // $ANTLR start "TkCustomAttributeArgs"
  public final void mTkCustomAttributeArgs() throws RecognitionException {
    try {
      int _type = TkCustomAttributeArgs;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:941:25: ( 'CUSTOM_ATTRIBUTE_ARGS' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:941:27: 'CUSTOM_ATTRIBUTE_ARGS'
      {
        match("CUSTOM_ATTRIBUTE_ARGS");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkCustomAttributeArgs"

  // $ANTLR start "TkNewType"
  public final void mTkNewType() throws RecognitionException {
    try {
      int _type = TkNewType;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:943:25: ( 'NEW_TYPE' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:943:27: 'NEW_TYPE'
      {
        match("NEW_TYPE");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkNewType"

  // $ANTLR start "TkNewTypeName"
  public final void mTkNewTypeName() throws RecognitionException {
    try {
      int _type = TkNewTypeName;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:945:25: ( 'NEW_TYPE_NAME' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:945:27: 'NEW_TYPE_NAME'
      {
        match("NEW_TYPE_NAME");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkNewTypeName"

  // $ANTLR start "TkNewTypeDecl"
  public final void mTkNewTypeDecl() throws RecognitionException {
    try {
      int _type = TkNewTypeDecl;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:947:25: ( 'NEW_TYPE_DECL' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:947:27: 'NEW_TYPE_DECL'
      {
        match("NEW_TYPE_DECL");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkNewTypeDecl"

  // $ANTLR start "TkClass"
  public final void mTkClass() throws RecognitionException {
    try {
      int _type = TkClass;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:949:25: ( 'CLASS' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:949:27: 'CLASS'
      {
        match("CLASS");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkClass"

  // $ANTLR start "TkRecord"
  public final void mTkRecord() throws RecognitionException {
    try {
      int _type = TkRecord;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:951:25: ( 'RECORD_TYPE' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:951:27: 'RECORD_TYPE'
      {
        match("RECORD_TYPE");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkRecord"

  // $ANTLR start "TkRecordHelper"
  public final void mTkRecordHelper() throws RecognitionException {
    try {
      int _type = TkRecordHelper;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:953:25: ( 'RECORD_HELPER' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:953:27: 'RECORD_HELPER'
      {
        match("RECORD_HELPER");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkRecordHelper"

  // $ANTLR start "TkInterface"
  public final void mTkInterface() throws RecognitionException {
    try {
      int _type = TkInterface;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:955:25: ( 'INTERFACE_TYPE' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:955:27: 'INTERFACE_TYPE'
      {
        match("INTERFACE_TYPE");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkInterface"

  // $ANTLR start "TkObject"
  public final void mTkObject() throws RecognitionException {
    try {
      int _type = TkObject;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:957:25: ( 'OBJECT_TYPE' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:957:27: 'OBJECT_TYPE'
      {
        match("OBJECT_TYPE");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkObject"

  // $ANTLR start "TkClassOfType"
  public final void mTkClassOfType() throws RecognitionException {
    try {
      int _type = TkClassOfType;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:959:25: ( 'CLASS_OF_TYPE' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:959:27: 'CLASS_OF_TYPE'
      {
        match("CLASS_OF_TYPE");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkClassOfType"

  // $ANTLR start "TkVariableType"
  public final void mTkVariableType() throws RecognitionException {
    try {
      int _type = TkVariableType;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:961:25: ( 'VARIABLE_TYPE' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:961:27: 'VARIABLE_TYPE'
      {
        match("VARIABLE_TYPE");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkVariableType"

  // $ANTLR start "TkVariableIdents"
  public final void mTkVariableIdents() throws RecognitionException {
    try {
      int _type = TkVariableIdents;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:963:25: ( 'VARIABLE_IDENTS' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:963:27: 'VARIABLE_IDENTS'
      {
        match("VARIABLE_IDENTS");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkVariableIdents"

  // $ANTLR start "TkVariableParam"
  public final void mTkVariableParam() throws RecognitionException {
    try {
      int _type = TkVariableParam;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:965:25: ( 'VARIABLE_PARAM' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:965:27: 'VARIABLE_PARAM'
      {
        match("VARIABLE_PARAM");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkVariableParam"

  // $ANTLR start "TkGuid"
  public final void mTkGuid() throws RecognitionException {
    try {
      int _type = TkGuid;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:967:25: ( 'INTERFACE_GUID' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:967:27: 'INTERFACE_GUID'
      {
        match("INTERFACE_GUID");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkGuid"

  // $ANTLR start "TkClassParents"
  public final void mTkClassParents() throws RecognitionException {
    try {
      int _type = TkClassParents;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:969:25: ( 'CLASS_PARENTS' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:969:27: 'CLASS_PARENTS'
      {
        match("CLASS_PARENTS");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkClassParents"

  // $ANTLR start "TkClassField"
  public final void mTkClassField() throws RecognitionException {
    try {
      int _type = TkClassField;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:971:25: ( 'CLASS_FIELD' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:971:27: 'CLASS_FIELD'
      {
        match("CLASS_FIELD");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkClassField"

  // $ANTLR start "TkAnonymousExpression"
  public final void mTkAnonymousExpression() throws RecognitionException {
    try {
      int _type = TkAnonymousExpression;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:973:25: ( 'ANONYMOUS_EXPRESSION' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:973:27: 'ANONYMOUS_EXPRESSION'
      {
        match("ANONYMOUS_EXPRESSION");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkAnonymousExpression"

  // $ANTLR start "TkAssemblerInstructions"
  public final void mTkAssemblerInstructions() throws RecognitionException {
    try {
      int _type = TkAssemblerInstructions;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:975:25: ( 'ASSEMBLER_INSTRUCTIONS' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:975:27: 'ASSEMBLER_INSTRUCTIONS'
      {
        match("ASSEMBLER_INSTRUCTIONS");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkAssemblerInstructions"

  // $ANTLR start "TkBlockDeclSection"
  public final void mTkBlockDeclSection() throws RecognitionException {
    try {
      int _type = TkBlockDeclSection;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:977:25: ( 'BLOCK_DECL_SECTION' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:977:27: 'BLOCK_DECL_SECTION'
      {
        match("BLOCK_DECL_SECTION");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkBlockDeclSection"

  // $ANTLR start "TkExceptionHandlerIdent"
  public final void mTkExceptionHandlerIdent() throws RecognitionException {
    try {
      int _type = TkExceptionHandlerIdent;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:979:25: ( 'EXCEPTION_HANDLER_IDENT' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:979:27: 'EXCEPTION_HANDLER_IDENT'
      {
        match("EXCEPTION_HANDLER_IDENT");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkExceptionHandlerIdent"

  // $ANTLR start "TkExceptionHandler"
  public final void mTkExceptionHandler() throws RecognitionException {
    try {
      int _type = TkExceptionHandler;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:981:25: ( 'EXCEPTION_HANDLER' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:981:27: 'EXCEPTION_HANDLER'
      {
        match("EXCEPTION_HANDLER");
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkExceptionHandler"

  // $ANTLR start "TkIdentifier"
  public final void mTkIdentifier() throws RecognitionException {
    try {
      int _type = TkIdentifier;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:983:25: ( ( Alpha | '_' ) ( Alpha | Digit | '_' )* )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:983:27: ( Alpha | '_' ) ( Alpha | Digit | '_' )*
      {
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:983:27: ( Alpha | '_' )
        int alt1 = 2;
        int LA1_0 = input.LA(1);
        if (((LA1_0 >= 'A' && LA1_0 <= 'Z')
            || (LA1_0 >= 'a' && LA1_0 <= 'z')
            || (LA1_0 >= '\u0080' && LA1_0 <= '\uFFFE'))) {
          alt1 = 1;
        } else if ((LA1_0 == '_')) {
          alt1 = 2;
        } else {
          NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
          throw nvae;
        }

        switch (alt1) {
          case 1:
            // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:983:28: Alpha
            {
              mAlpha();
            }
            break;
          case 2:
            // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:983:36: '_'
            {
              match('_');
            }
            break;
        }

        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:983:41: ( Alpha | Digit | '_' )*
        loop2:
        while (true) {
          int alt2 = 4;
          int LA2_0 = input.LA(1);
          if (((LA2_0 >= 'A' && LA2_0 <= 'Z')
              || (LA2_0 >= 'a' && LA2_0 <= 'z')
              || (LA2_0 >= '\u0080' && LA2_0 <= '\uFFFE'))) {
            alt2 = 1;
          } else if (((LA2_0 >= '0' && LA2_0 <= '9'))) {
            alt2 = 2;
          } else if ((LA2_0 == '_')) {
            alt2 = 3;
          }

          switch (alt2) {
            case 1:
              // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:983:42: Alpha
              {
                mAlpha();
              }
              break;
            case 2:
              // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:983:50: Digit
              {
                mDigit();
              }
              break;
            case 3:
              // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:983:58: '_'
              {
                match('_');
              }
              break;

            default:
              break loop2;
          }
        }
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkIdentifier"

  // $ANTLR start "TkIntNum"
  public final void mTkIntNum() throws RecognitionException {
    try {
      int _type = TkIntNum;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:985:25: ( Digitseq )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:985:27: Digitseq
      {
        mDigitseq();
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkIntNum"

  // $ANTLR start "TkRealNum"
  public final void mTkRealNum() throws RecognitionException {
    try {
      int _type = TkRealNum;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:988:25: ( Digitseq ({...}? => '.' Digitseq )? ( ( 'e' | 'E' ) ( '+' | '-' )? Digitseq )? )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:988:27: Digitseq ({...}? => '.' Digitseq )? ( ( 'e' | 'E' ) ( '+' | '-' )? Digitseq )?
      {
        mDigitseq();

        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:988:36: ({...}? => '.' Digitseq )?
        int alt3 = 2;
        int LA3_0 = input.LA(1);
        if ((LA3_0 == '.') && ((input.LA(2) != '.'))) {
          alt3 = 1;
        }
        switch (alt3) {
          case 1:
            // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:988:37: {...}? => '.' Digitseq
            {
              if (!((input.LA(2) != '.'))) {
                throw new FailedPredicateException(input, "TkRealNum", " input.LA(2) != '.' ");
              }
              match('.');
              mDigitseq();
            }
            break;
        }

        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:988:79: ( ( 'e' | 'E' ) ( '+' | '-' )? Digitseq )?
        int alt5 = 2;
        int LA5_0 = input.LA(1);
        if ((LA5_0 == 'E' || LA5_0 == 'e')) {
          alt5 = 1;
        }
        switch (alt5) {
          case 1:
            // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:988:80: ( 'e' | 'E' ) ( '+' | '-' )? Digitseq
            {
              if (input.LA(1) == 'E' || input.LA(1) == 'e') {
                input.consume();
              } else {
                MismatchedSetException mse = new MismatchedSetException(null, input);
                recover(mse);
                throw mse;
              }
              // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:988:90: ( '+' | '-' )?
              int alt4 = 2;
              int LA4_0 = input.LA(1);
              if ((LA4_0 == '+' || LA4_0 == '-')) {
                alt4 = 1;
              }
              switch (alt4) {
                case 1:
                  // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:
                  {
                    if (input.LA(1) == '+' || input.LA(1) == '-') {
                      input.consume();
                    } else {
                      MismatchedSetException mse = new MismatchedSetException(null, input);
                      recover(mse);
                      throw mse;
                    }
                  }
                  break;
              }

              mDigitseq();
            }
            break;
        }
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkRealNum"

  // $ANTLR start "TkHexNum"
  public final void mTkHexNum() throws RecognitionException {
    try {
      int _type = TkHexNum;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:990:25: ( '$' Hexdigitseq )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:990:27: '$' Hexdigitseq
      {
        match('$');
        mHexdigitseq();
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkHexNum"

  // $ANTLR start "TkAsmHexNum"
  public final void mTkAsmHexNum() throws RecognitionException {
    try {
      int _type = TkAsmHexNum;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:992:25: ({...}? => Hexdigitseq ( 'h' | 'H' ) )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:992:27: {...}? => Hexdigitseq ( 'h' | 'H' )
      {
        if (!((asmMode))) {
          throw new FailedPredicateException(input, "TkAsmHexNum", " asmMode ");
        }
        mHexdigitseq();

        if (input.LA(1) == 'H' || input.LA(1) == 'h') {
          input.consume();
        } else {
          MismatchedSetException mse = new MismatchedSetException(null, input);
          recover(mse);
          throw mse;
        }
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkAsmHexNum"

  // $ANTLR start "TkAsmHexLabel"
  public final void mTkAsmHexLabel() throws RecognitionException {
    try {
      int _type = TkAsmHexLabel;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:994:25: ({...}? => Hexdigitseq ':' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:994:27: {...}? => Hexdigitseq ':'
      {
        if (!((asmMode))) {
          throw new FailedPredicateException(input, "TkAsmHexLabel", " asmMode ");
        }
        mHexdigitseq();

        match(':');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "TkAsmHexLabel"

  // $ANTLR start "QuotedString"
  public final void mQuotedString() throws RecognitionException {
    try {
      int _type = QuotedString;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:996:25: ( '\\'' ( '\\'\\'' |~ ( '\\'' ) )* '\\'' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:996:27: '\\'' ( '\\'\\'' |~ ( '\\'' ) )* '\\''
      {
        match('\'');
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:996:32: ( '\\'\\'' |~ ( '\\'' ) )*
        loop6:
        while (true) {
          int alt6 = 3;
          int LA6_0 = input.LA(1);
          if ((LA6_0 == '\'')) {
            int LA6_1 = input.LA(2);
            if ((LA6_1 == '\'')) {
              alt6 = 1;
            }

          } else if (((LA6_0 >= '\u0000' && LA6_0 <= '&') || (LA6_0 >= '(' && LA6_0 <= '\uFFFF'))) {
            alt6 = 2;
          }

          switch (alt6) {
            case 1:
              // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:996:33: '\\'\\''
              {
                match("''");
              }
              break;
            case 2:
              // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:996:42: ~ ( '\\'' )
              {
                if ((input.LA(1) >= '\u0000' && input.LA(1) <= '&')
                    || (input.LA(1) >= '(' && input.LA(1) <= '\uFFFF')) {
                  input.consume();
                } else {
                  MismatchedSetException mse = new MismatchedSetException(null, input);
                  recover(mse);
                  throw mse;
                }
              }
              break;

            default:
              break loop6;
          }
        }

        match('\'');
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "QuotedString"

  // $ANTLR start "ControlString"
  public final void mControlString() throws RecognitionException {
    try {
      int _type = ControlString;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:998:25: ( Controlchar ( Controlchar )* )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:998:27: Controlchar ( Controlchar )*
      {
        mControlchar();

        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:998:39: ( Controlchar )*
        loop7:
        while (true) {
          int alt7 = 2;
          int LA7_0 = input.LA(1);
          if ((LA7_0 == '#')) {
            alt7 = 1;
          }

          switch (alt7) {
            case 1:
              // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:998:40: Controlchar
              {
                mControlchar();
              }
              break;

            default:
              break loop7;
          }
        }
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "ControlString"

  // $ANTLR start "Controlchar"
  public final void mControlchar() throws RecognitionException {
    try {
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1006:25: ( '#' Digitseq | '#' '$' Hexdigitseq )
      int alt8 = 2;
      int LA8_0 = input.LA(1);
      if ((LA8_0 == '#')) {
        int LA8_1 = input.LA(2);
        if ((LA8_1 == '$')) {
          alt8 = 2;
        } else if (((LA8_1 >= '0' && LA8_1 <= '9'))) {
          alt8 = 1;
        } else {
          int nvaeMark = input.mark();
          try {
            input.consume();
            NoViableAltException nvae = new NoViableAltException("", 8, 1, input);
            throw nvae;
          } finally {
            input.rewind(nvaeMark);
          }
        }

      } else {
        NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
        throw nvae;
      }

      switch (alt8) {
        case 1:
          // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1006:27: '#' Digitseq
          {
            match('#');
            mDigitseq();
          }
          break;
        case 2:
          // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1007:27: '#' '$' Hexdigitseq
          {
            match('#');
            match('$');
            mHexdigitseq();
          }
          break;
      }
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "Controlchar"

  // $ANTLR start "Alpha"
  public final void mAlpha() throws RecognitionException {
    try {
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1010:25: ( 'a' .. 'z' | 'A' .. 'Z' | '\\u0080' .. '\\uFFFE' ~ ( '\\uFEFF' ) )
      int alt9 = 3;
      int LA9_0 = input.LA(1);
      if (((LA9_0 >= 'a' && LA9_0 <= 'z'))) {
        alt9 = 1;
      } else if (((LA9_0 >= 'A' && LA9_0 <= 'Z'))) {
        alt9 = 2;
      } else if (((LA9_0 >= '\u0080' && LA9_0 <= '\uFFFE'))) {
        alt9 = 3;
      } else {
        NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
        throw nvae;
      }

      switch (alt9) {
        case 1:
          // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1010:27: 'a' .. 'z'
          {
            matchRange('a', 'z');
          }
          break;
        case 2:
          // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1011:27: 'A' .. 'Z'
          {
            matchRange('A', 'Z');
          }
          break;
        case 3:
          // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1012:27: '\\u0080' .. '\\uFFFE' ~ ( '\\uFEFF' )
          {
            matchRange('\u0080', '\uFFFE');
            if ((input.LA(1) >= '\u0000' && input.LA(1) <= '\uFEFE')
                || (input.LA(1) >= '\uFF00' && input.LA(1) <= '\uFFFF')) {
              input.consume();
            } else {
              MismatchedSetException mse = new MismatchedSetException(null, input);
              recover(mse);
              throw mse;
            }
          }
          break;
      }
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "Alpha"

  // $ANTLR start "Digit"
  public final void mDigit() throws RecognitionException {
    try {
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1015:25: ( '0' .. '9' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:
      {
        if ((input.LA(1) >= '0' && input.LA(1) <= '9')) {
          input.consume();
        } else {
          MismatchedSetException mse = new MismatchedSetException(null, input);
          recover(mse);
          throw mse;
        }
      }

    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "Digit"

  // $ANTLR start "Digitseq"
  public final void mDigitseq() throws RecognitionException {
    try {
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1018:25: ( Digit ( Digit )* )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1018:27: Digit ( Digit )*
      {
        mDigit();

        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1018:33: ( Digit )*
        loop10:
        while (true) {
          int alt10 = 2;
          int LA10_0 = input.LA(1);
          if (((LA10_0 >= '0' && LA10_0 <= '9'))) {
            alt10 = 1;
          }

          switch (alt10) {
            case 1:
              // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:
              {
                if ((input.LA(1) >= '0' && input.LA(1) <= '9')) {
                  input.consume();
                } else {
                  MismatchedSetException mse = new MismatchedSetException(null, input);
                  recover(mse);
                  throw mse;
                }
              }
              break;

            default:
              break loop10;
          }
        }
      }

    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "Digitseq"

  // $ANTLR start "Hexdigit"
  public final void mHexdigit() throws RecognitionException {
    try {
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1021:25: ( Digit | 'a' .. 'f' | 'A' .. 'F' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:
      {
        if ((input.LA(1) >= '0' && input.LA(1) <= '9')
            || (input.LA(1) >= 'A' && input.LA(1) <= 'F')
            || (input.LA(1) >= 'a' && input.LA(1) <= 'f')) {
          input.consume();
        } else {
          MismatchedSetException mse = new MismatchedSetException(null, input);
          recover(mse);
          throw mse;
        }
      }

    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "Hexdigit"

  // $ANTLR start "Hexdigitseq"
  public final void mHexdigitseq() throws RecognitionException {
    try {
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1024:24: ( Hexdigit ( Hexdigit )* )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1024:26: Hexdigit ( Hexdigit )*
      {
        mHexdigit();

        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1024:35: ( Hexdigit )*
        loop11:
        while (true) {
          int alt11 = 2;
          int LA11_0 = input.LA(1);
          if (((LA11_0 >= '0' && LA11_0 <= '9')
              || (LA11_0 >= 'A' && LA11_0 <= 'F')
              || (LA11_0 >= 'a' && LA11_0 <= 'f'))) {
            alt11 = 1;
          }

          switch (alt11) {
            case 1:
              // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:
              {
                if ((input.LA(1) >= '0' && input.LA(1) <= '9')
                    || (input.LA(1) >= 'A' && input.LA(1) <= 'F')
                    || (input.LA(1) >= 'a' && input.LA(1) <= 'f')) {
                  input.consume();
                } else {
                  MismatchedSetException mse = new MismatchedSetException(null, input);
                  recover(mse);
                  throw mse;
                }
              }
              break;

            default:
              break loop11;
          }
        }
      }

    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "Hexdigitseq"

  // $ANTLR start "COMMENT"
  public final void mCOMMENT() throws RecognitionException {
    try {
      int _type = COMMENT;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1028:25: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '(*' ( options {greedy=false; } : . )* '*)' | '{' ( options {greedy=false; } : . )* '}' )
      int alt16 = 3;
      switch (input.LA(1)) {
        case '/':
          {
            alt16 = 1;
          }
          break;
        case '(':
          {
            alt16 = 2;
          }
          break;
        case '{':
          {
            alt16 = 3;
          }
          break;
        default:
          NoViableAltException nvae = new NoViableAltException("", 16, 0, input);
          throw nvae;
      }
      switch (alt16) {
        case 1:
          // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1028:28: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
          {
            match("//");

            // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1028:33: (~ ( '\\n' | '\\r' ) )*
            loop12:
            while (true) {
              int alt12 = 2;
              int LA12_0 = input.LA(1);
              if (((LA12_0 >= '\u0000' && LA12_0 <= '\t')
                  || (LA12_0 >= '\u000B' && LA12_0 <= '\f')
                  || (LA12_0 >= '\u000E' && LA12_0 <= '\uFFFF'))) {
                alt12 = 1;
              }

              switch (alt12) {
                case 1:
                  // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:
                  {
                    if ((input.LA(1) >= '\u0000' && input.LA(1) <= '\t')
                        || (input.LA(1) >= '\u000B' && input.LA(1) <= '\f')
                        || (input.LA(1) >= '\u000E' && input.LA(1) <= '\uFFFF')) {
                      input.consume();
                    } else {
                      MismatchedSetException mse = new MismatchedSetException(null, input);
                      recover(mse);
                      throw mse;
                    }
                  }
                  break;

                default:
                  break loop12;
              }
            }

            // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1028:47: ( '\\r' )?
            int alt13 = 2;
            int LA13_0 = input.LA(1);
            if ((LA13_0 == '\r')) {
              alt13 = 1;
            }
            switch (alt13) {
              case 1:
                // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1028:47: '\\r'
                {
                  match('\r');
                }
                break;
            }

            match('\n');
            _channel = HIDDEN;
          }
          break;
        case 2:
          // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1029:28: '(*' ( options {greedy=false; } : . )* '*)'
          {
            match("(*");

            // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1029:33: ( options {greedy=false; } : . )*
            loop14:
            while (true) {
              int alt14 = 2;
              int LA14_0 = input.LA(1);
              if ((LA14_0 == '*')) {
                int LA14_1 = input.LA(2);
                if ((LA14_1 == ')')) {
                  alt14 = 2;
                } else if (((LA14_1 >= '\u0000' && LA14_1 <= '(')
                    || (LA14_1 >= '*' && LA14_1 <= '\uFFFF'))) {
                  alt14 = 1;
                }

              } else if (((LA14_0 >= '\u0000' && LA14_0 <= ')')
                  || (LA14_0 >= '+' && LA14_0 <= '\uFFFF'))) {
                alt14 = 1;
              }

              switch (alt14) {
                case 1:
                  // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1029:61: .
                  {
                    matchAny();
                  }
                  break;

                default:
                  break loop14;
              }
            }

            match("*)");

            _channel = HIDDEN;
          }
          break;
        case 3:
          // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1030:28: '{' ( options {greedy=false; } : . )* '}'
          {
            match('{');
            // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1030:32: ( options {greedy=false; } : . )*
            loop15:
            while (true) {
              int alt15 = 2;
              int LA15_0 = input.LA(1);
              if ((LA15_0 == '}')) {
                alt15 = 2;
              } else if (((LA15_0 >= '\u0000' && LA15_0 <= '|')
                  || (LA15_0 >= '~' && LA15_0 <= '\uFFFF'))) {
                alt15 = 1;
              }

              switch (alt15) {
                case 1:
                  // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1030:60: .
                  {
                    matchAny();
                  }
                  break;

                default:
                  break loop15;
              }
            }

            match('}');
            _channel = HIDDEN;
          }
          break;
      }
      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "COMMENT"

  // $ANTLR start "WS"
  public final void mWS() throws RecognitionException {
    try {
      int _type = WS;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1032:25: ( ( ' ' | '\\t' | '\\r' | '\\n' | '\\f' )+ )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1032:27: ( ' ' | '\\t' | '\\r' | '\\n' | '\\f' )+
      {
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1032:27: ( ' ' | '\\t' | '\\r' | '\\n' | '\\f' )+
        int cnt17 = 0;
        loop17:
        while (true) {
          int alt17 = 2;
          int LA17_0 = input.LA(1);
          if (((LA17_0 >= '\t' && LA17_0 <= '\n')
              || (LA17_0 >= '\f' && LA17_0 <= '\r')
              || LA17_0 == ' ')) {
            alt17 = 1;
          }

          switch (alt17) {
            case 1:
              // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:
              {
                if ((input.LA(1) >= '\t' && input.LA(1) <= '\n')
                    || (input.LA(1) >= '\f' && input.LA(1) <= '\r')
                    || input.LA(1) == ' ') {
                  input.consume();
                } else {
                  MismatchedSetException mse = new MismatchedSetException(null, input);
                  recover(mse);
                  throw mse;
                }
              }
              break;

            default:
              if (cnt17 >= 1) break loop17;
              EarlyExitException eee = new EarlyExitException(17, input);
              throw eee;
          }
          cnt17++;
        }

        _channel = HIDDEN;
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "WS"

  // $ANTLR start "UnicodeBOM"
  public final void mUnicodeBOM() throws RecognitionException {
    try {
      int _type = UnicodeBOM;
      int _channel = DEFAULT_TOKEN_CHANNEL;
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1034:25: ( '\\uFEFF' )
      // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1034:27: '\\uFEFF'
      {
        match('\uFEFF');
        _channel = HIDDEN;
      }

      state.type = _type;
      state.channel = _channel;
    } finally {
      // do for sure before leaving
    }
  }
  // $ANTLR end "UnicodeBOM"

  @Override
  public void mTokens() throws RecognitionException {
    // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:8: ( ABSOLUTE | ABSTRACT | ADD | AND | ANSISTRING | ARRAY | AS | ASM | ASSEMBLER | ASSEMBLY | AT | AUTOMATED | BEGIN | BREAK | CASE | CDECL | CLASS | CONST | CONSTRUCTOR | CONTAINS | CONTINUE | DEFAULT | DEPRECATED | DESTRUCTOR | DISPID | DISPINTERFACE | DIV | DO | DOWNTO | DQ | DW | DYNAMIC | ELSE | END | EXCEPT | EXIT | EXPERIMENTAL | EXPORT | EXPORTS | EXTERNAL | FAR | FILE | FINAL | FINALIZATION | FINALLY | FOR | FORWARD | FUNCTION | GOTO | HELPER | IF | IMPLEMENTATION | IMPLEMENTS | IN | INDEX | INHERITED | INITIALIZATION | INLINE | INTERFACE | IS | LABEL | LIBRARY | LOCAL | MESSAGE | MOD | NAME | NEAR | NIL | NODEFAULT | NOT | OBJECT | OF | ON | OPERATOR | OR | OUT | OVERLOAD | OVERRIDE | PACKAGE | PACKED | PASCAL | PLATFORM | POINTER | PRIVATE | PROCEDURE | PROGRAM | PROPERTY | PROTECTED | PUBLIC | PUBLISHED | RAISE | READ | READONLY | RECORD | REFERENCE | REGISTER | REINTRODUCE | REMOVE | REPEAT | REQUIRES | RESIDENT | RESOURCESTRING | SAFECALL | SEALED | SET | SHL | SHR | STATIC | STDCALL | STORED | STRICT | STRING | THEN | THREADVAR | TO | TRY | TYPE | UNIT | UNSAFE | UNTIL | USES | VAR | VARARGS | VARIANT | VIRTUAL | WHILE | WITH | WRITE | WRITEONLY | XOR | FALSE | TRUE | PLUS | MINUS | STAR | SLASH | ASSIGN | COMMA | SEMI | COLON | EQUAL | NOT_EQUAL | LT | LE | GE | GT | LPAREN | RPAREN | LBRACK | LBRACK2 | RBRACK | RBRACK2 | POINTER2 | AT2 | DOT | DOTDOT | LCURLY | RCURLY | AMPERSAND | TkGlobalFunction | TkFunctionName | TkConstantName | TkFunctionArgs | TkFunctionBody | TkFunctionReturn | TkCustomAttribute | TkCustomAttributeArgs | TkNewType | TkNewTypeName | TkNewTypeDecl | TkClass | TkRecord | TkRecordHelper | TkInterface | TkObject | TkClassOfType | TkVariableType | TkVariableIdents | TkVariableParam | TkGuid | TkClassParents | TkClassField | TkAnonymousExpression | TkAssemblerInstructions | TkBlockDeclSection | TkExceptionHandlerIdent | TkExceptionHandler | TkIdentifier | TkIntNum | TkRealNum | TkHexNum | TkAsmHexNum | TkAsmHexLabel | QuotedString | ControlString | COMMENT | WS | UnicodeBOM )
    int alt18 = 198;
    alt18 = dfa18.predict(input);
    switch (alt18) {
      case 1:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:10: ABSOLUTE
        {
          mABSOLUTE();
        }
        break;
      case 2:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:19: ABSTRACT
        {
          mABSTRACT();
        }
        break;
      case 3:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:28: ADD
        {
          mADD();
        }
        break;
      case 4:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:32: AND
        {
          mAND();
        }
        break;
      case 5:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:36: ANSISTRING
        {
          mANSISTRING();
        }
        break;
      case 6:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:47: ARRAY
        {
          mARRAY();
        }
        break;
      case 7:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:53: AS
        {
          mAS();
        }
        break;
      case 8:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:56: ASM
        {
          mASM();
        }
        break;
      case 9:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:60: ASSEMBLER
        {
          mASSEMBLER();
        }
        break;
      case 10:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:70: ASSEMBLY
        {
          mASSEMBLY();
        }
        break;
      case 11:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:79: AT
        {
          mAT();
        }
        break;
      case 12:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:82: AUTOMATED
        {
          mAUTOMATED();
        }
        break;
      case 13:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:92: BEGIN
        {
          mBEGIN();
        }
        break;
      case 14:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:98: BREAK
        {
          mBREAK();
        }
        break;
      case 15:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:104: CASE
        {
          mCASE();
        }
        break;
      case 16:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:109: CDECL
        {
          mCDECL();
        }
        break;
      case 17:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:115: CLASS
        {
          mCLASS();
        }
        break;
      case 18:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:121: CONST
        {
          mCONST();
        }
        break;
      case 19:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:127: CONSTRUCTOR
        {
          mCONSTRUCTOR();
        }
        break;
      case 20:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:139: CONTAINS
        {
          mCONTAINS();
        }
        break;
      case 21:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:148: CONTINUE
        {
          mCONTINUE();
        }
        break;
      case 22:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:157: DEFAULT
        {
          mDEFAULT();
        }
        break;
      case 23:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:165: DEPRECATED
        {
          mDEPRECATED();
        }
        break;
      case 24:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:176: DESTRUCTOR
        {
          mDESTRUCTOR();
        }
        break;
      case 25:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:187: DISPID
        {
          mDISPID();
        }
        break;
      case 26:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:194: DISPINTERFACE
        {
          mDISPINTERFACE();
        }
        break;
      case 27:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:208: DIV
        {
          mDIV();
        }
        break;
      case 28:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:212: DO
        {
          mDO();
        }
        break;
      case 29:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:215: DOWNTO
        {
          mDOWNTO();
        }
        break;
      case 30:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:222: DQ
        {
          mDQ();
        }
        break;
      case 31:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:225: DW
        {
          mDW();
        }
        break;
      case 32:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:228: DYNAMIC
        {
          mDYNAMIC();
        }
        break;
      case 33:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:236: ELSE
        {
          mELSE();
        }
        break;
      case 34:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:241: END
        {
          mEND();
        }
        break;
      case 35:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:245: EXCEPT
        {
          mEXCEPT();
        }
        break;
      case 36:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:252: EXIT
        {
          mEXIT();
        }
        break;
      case 37:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:257: EXPERIMENTAL
        {
          mEXPERIMENTAL();
        }
        break;
      case 38:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:270: EXPORT
        {
          mEXPORT();
        }
        break;
      case 39:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:277: EXPORTS
        {
          mEXPORTS();
        }
        break;
      case 40:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:285: EXTERNAL
        {
          mEXTERNAL();
        }
        break;
      case 41:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:294: FAR
        {
          mFAR();
        }
        break;
      case 42:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:298: FILE
        {
          mFILE();
        }
        break;
      case 43:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:303: FINAL
        {
          mFINAL();
        }
        break;
      case 44:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:309: FINALIZATION
        {
          mFINALIZATION();
        }
        break;
      case 45:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:322: FINALLY
        {
          mFINALLY();
        }
        break;
      case 46:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:330: FOR
        {
          mFOR();
        }
        break;
      case 47:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:334: FORWARD
        {
          mFORWARD();
        }
        break;
      case 48:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:342: FUNCTION
        {
          mFUNCTION();
        }
        break;
      case 49:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:351: GOTO
        {
          mGOTO();
        }
        break;
      case 50:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:356: HELPER
        {
          mHELPER();
        }
        break;
      case 51:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:363: IF
        {
          mIF();
        }
        break;
      case 52:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:366: IMPLEMENTATION
        {
          mIMPLEMENTATION();
        }
        break;
      case 53:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:381: IMPLEMENTS
        {
          mIMPLEMENTS();
        }
        break;
      case 54:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:392: IN
        {
          mIN();
        }
        break;
      case 55:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:395: INDEX
        {
          mINDEX();
        }
        break;
      case 56:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:401: INHERITED
        {
          mINHERITED();
        }
        break;
      case 57:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:411: INITIALIZATION
        {
          mINITIALIZATION();
        }
        break;
      case 58:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:426: INLINE
        {
          mINLINE();
        }
        break;
      case 59:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:433: INTERFACE
        {
          mINTERFACE();
        }
        break;
      case 60:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:443: IS
        {
          mIS();
        }
        break;
      case 61:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:446: LABEL
        {
          mLABEL();
        }
        break;
      case 62:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:452: LIBRARY
        {
          mLIBRARY();
        }
        break;
      case 63:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:460: LOCAL
        {
          mLOCAL();
        }
        break;
      case 64:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:466: MESSAGE
        {
          mMESSAGE();
        }
        break;
      case 65:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:474: MOD
        {
          mMOD();
        }
        break;
      case 66:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:478: NAME
        {
          mNAME();
        }
        break;
      case 67:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:483: NEAR
        {
          mNEAR();
        }
        break;
      case 68:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:488: NIL
        {
          mNIL();
        }
        break;
      case 69:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:492: NODEFAULT
        {
          mNODEFAULT();
        }
        break;
      case 70:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:502: NOT
        {
          mNOT();
        }
        break;
      case 71:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:506: OBJECT
        {
          mOBJECT();
        }
        break;
      case 72:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:513: OF
        {
          mOF();
        }
        break;
      case 73:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:516: ON
        {
          mON();
        }
        break;
      case 74:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:519: OPERATOR
        {
          mOPERATOR();
        }
        break;
      case 75:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:528: OR
        {
          mOR();
        }
        break;
      case 76:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:531: OUT
        {
          mOUT();
        }
        break;
      case 77:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:535: OVERLOAD
        {
          mOVERLOAD();
        }
        break;
      case 78:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:544: OVERRIDE
        {
          mOVERRIDE();
        }
        break;
      case 79:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:553: PACKAGE
        {
          mPACKAGE();
        }
        break;
      case 80:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:561: PACKED
        {
          mPACKED();
        }
        break;
      case 81:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:568: PASCAL
        {
          mPASCAL();
        }
        break;
      case 82:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:575: PLATFORM
        {
          mPLATFORM();
        }
        break;
      case 83:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:584: POINTER
        {
          mPOINTER();
        }
        break;
      case 84:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:592: PRIVATE
        {
          mPRIVATE();
        }
        break;
      case 85:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:600: PROCEDURE
        {
          mPROCEDURE();
        }
        break;
      case 86:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:610: PROGRAM
        {
          mPROGRAM();
        }
        break;
      case 87:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:618: PROPERTY
        {
          mPROPERTY();
        }
        break;
      case 88:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:627: PROTECTED
        {
          mPROTECTED();
        }
        break;
      case 89:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:637: PUBLIC
        {
          mPUBLIC();
        }
        break;
      case 90:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:644: PUBLISHED
        {
          mPUBLISHED();
        }
        break;
      case 91:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:654: RAISE
        {
          mRAISE();
        }
        break;
      case 92:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:660: READ
        {
          mREAD();
        }
        break;
      case 93:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:665: READONLY
        {
          mREADONLY();
        }
        break;
      case 94:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:674: RECORD
        {
          mRECORD();
        }
        break;
      case 95:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:681: REFERENCE
        {
          mREFERENCE();
        }
        break;
      case 96:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:691: REGISTER
        {
          mREGISTER();
        }
        break;
      case 97:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:700: REINTRODUCE
        {
          mREINTRODUCE();
        }
        break;
      case 98:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:712: REMOVE
        {
          mREMOVE();
        }
        break;
      case 99:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:719: REPEAT
        {
          mREPEAT();
        }
        break;
      case 100:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:726: REQUIRES
        {
          mREQUIRES();
        }
        break;
      case 101:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:735: RESIDENT
        {
          mRESIDENT();
        }
        break;
      case 102:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:744: RESOURCESTRING
        {
          mRESOURCESTRING();
        }
        break;
      case 103:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:759: SAFECALL
        {
          mSAFECALL();
        }
        break;
      case 104:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:768: SEALED
        {
          mSEALED();
        }
        break;
      case 105:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:775: SET
        {
          mSET();
        }
        break;
      case 106:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:779: SHL
        {
          mSHL();
        }
        break;
      case 107:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:783: SHR
        {
          mSHR();
        }
        break;
      case 108:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:787: STATIC
        {
          mSTATIC();
        }
        break;
      case 109:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:794: STDCALL
        {
          mSTDCALL();
        }
        break;
      case 110:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:802: STORED
        {
          mSTORED();
        }
        break;
      case 111:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:809: STRICT
        {
          mSTRICT();
        }
        break;
      case 112:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:816: STRING
        {
          mSTRING();
        }
        break;
      case 113:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:823: THEN
        {
          mTHEN();
        }
        break;
      case 114:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:828: THREADVAR
        {
          mTHREADVAR();
        }
        break;
      case 115:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:838: TO
        {
          mTO();
        }
        break;
      case 116:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:841: TRY
        {
          mTRY();
        }
        break;
      case 117:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:845: TYPE
        {
          mTYPE();
        }
        break;
      case 118:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:850: UNIT
        {
          mUNIT();
        }
        break;
      case 119:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:855: UNSAFE
        {
          mUNSAFE();
        }
        break;
      case 120:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:862: UNTIL
        {
          mUNTIL();
        }
        break;
      case 121:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:868: USES
        {
          mUSES();
        }
        break;
      case 122:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:873: VAR
        {
          mVAR();
        }
        break;
      case 123:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:877: VARARGS
        {
          mVARARGS();
        }
        break;
      case 124:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:885: VARIANT
        {
          mVARIANT();
        }
        break;
      case 125:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:893: VIRTUAL
        {
          mVIRTUAL();
        }
        break;
      case 126:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:901: WHILE
        {
          mWHILE();
        }
        break;
      case 127:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:907: WITH
        {
          mWITH();
        }
        break;
      case 128:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:912: WRITE
        {
          mWRITE();
        }
        break;
      case 129:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:918: WRITEONLY
        {
          mWRITEONLY();
        }
        break;
      case 130:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:928: XOR
        {
          mXOR();
        }
        break;
      case 131:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:932: FALSE
        {
          mFALSE();
        }
        break;
      case 132:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:938: TRUE
        {
          mTRUE();
        }
        break;
      case 133:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:943: PLUS
        {
          mPLUS();
        }
        break;
      case 134:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:948: MINUS
        {
          mMINUS();
        }
        break;
      case 135:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:954: STAR
        {
          mSTAR();
        }
        break;
      case 136:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:959: SLASH
        {
          mSLASH();
        }
        break;
      case 137:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:965: ASSIGN
        {
          mASSIGN();
        }
        break;
      case 138:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:972: COMMA
        {
          mCOMMA();
        }
        break;
      case 139:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:978: SEMI
        {
          mSEMI();
        }
        break;
      case 140:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:983: COLON
        {
          mCOLON();
        }
        break;
      case 141:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:989: EQUAL
        {
          mEQUAL();
        }
        break;
      case 142:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:995: NOT_EQUAL
        {
          mNOT_EQUAL();
        }
        break;
      case 143:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1005: LT
        {
          mLT();
        }
        break;
      case 144:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1008: LE
        {
          mLE();
        }
        break;
      case 145:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1011: GE
        {
          mGE();
        }
        break;
      case 146:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1014: GT
        {
          mGT();
        }
        break;
      case 147:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1017: LPAREN
        {
          mLPAREN();
        }
        break;
      case 148:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1024: RPAREN
        {
          mRPAREN();
        }
        break;
      case 149:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1031: LBRACK
        {
          mLBRACK();
        }
        break;
      case 150:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1038: LBRACK2
        {
          mLBRACK2();
        }
        break;
      case 151:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1046: RBRACK
        {
          mRBRACK();
        }
        break;
      case 152:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1053: RBRACK2
        {
          mRBRACK2();
        }
        break;
      case 153:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1061: POINTER2
        {
          mPOINTER2();
        }
        break;
      case 154:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1070: AT2
        {
          mAT2();
        }
        break;
      case 155:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1074: DOT
        {
          mDOT();
        }
        break;
      case 156:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1078: DOTDOT
        {
          mDOTDOT();
        }
        break;
      case 157:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1085: LCURLY
        {
          mLCURLY();
        }
        break;
      case 158:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1092: RCURLY
        {
          mRCURLY();
        }
        break;
      case 159:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1099: AMPERSAND
        {
          mAMPERSAND();
        }
        break;
      case 160:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1109: TkGlobalFunction
        {
          mTkGlobalFunction();
        }
        break;
      case 161:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1126: TkFunctionName
        {
          mTkFunctionName();
        }
        break;
      case 162:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1141: TkConstantName
        {
          mTkConstantName();
        }
        break;
      case 163:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1156: TkFunctionArgs
        {
          mTkFunctionArgs();
        }
        break;
      case 164:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1171: TkFunctionBody
        {
          mTkFunctionBody();
        }
        break;
      case 165:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1186: TkFunctionReturn
        {
          mTkFunctionReturn();
        }
        break;
      case 166:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1203: TkCustomAttribute
        {
          mTkCustomAttribute();
        }
        break;
      case 167:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1221: TkCustomAttributeArgs
        {
          mTkCustomAttributeArgs();
        }
        break;
      case 168:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1243: TkNewType
        {
          mTkNewType();
        }
        break;
      case 169:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1253: TkNewTypeName
        {
          mTkNewTypeName();
        }
        break;
      case 170:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1267: TkNewTypeDecl
        {
          mTkNewTypeDecl();
        }
        break;
      case 171:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1281: TkClass
        {
          mTkClass();
        }
        break;
      case 172:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1289: TkRecord
        {
          mTkRecord();
        }
        break;
      case 173:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1298: TkRecordHelper
        {
          mTkRecordHelper();
        }
        break;
      case 174:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1313: TkInterface
        {
          mTkInterface();
        }
        break;
      case 175:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1325: TkObject
        {
          mTkObject();
        }
        break;
      case 176:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1334: TkClassOfType
        {
          mTkClassOfType();
        }
        break;
      case 177:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1348: TkVariableType
        {
          mTkVariableType();
        }
        break;
      case 178:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1363: TkVariableIdents
        {
          mTkVariableIdents();
        }
        break;
      case 179:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1380: TkVariableParam
        {
          mTkVariableParam();
        }
        break;
      case 180:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1396: TkGuid
        {
          mTkGuid();
        }
        break;
      case 181:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1403: TkClassParents
        {
          mTkClassParents();
        }
        break;
      case 182:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1418: TkClassField
        {
          mTkClassField();
        }
        break;
      case 183:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1431: TkAnonymousExpression
        {
          mTkAnonymousExpression();
        }
        break;
      case 184:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1453: TkAssemblerInstructions
        {
          mTkAssemblerInstructions();
        }
        break;
      case 185:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1477: TkBlockDeclSection
        {
          mTkBlockDeclSection();
        }
        break;
      case 186:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1496: TkExceptionHandlerIdent
        {
          mTkExceptionHandlerIdent();
        }
        break;
      case 187:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1520: TkExceptionHandler
        {
          mTkExceptionHandler();
        }
        break;
      case 188:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1539: TkIdentifier
        {
          mTkIdentifier();
        }
        break;
      case 189:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1552: TkIntNum
        {
          mTkIntNum();
        }
        break;
      case 190:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1561: TkRealNum
        {
          mTkRealNum();
        }
        break;
      case 191:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1571: TkHexNum
        {
          mTkHexNum();
        }
        break;
      case 192:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1580: TkAsmHexNum
        {
          mTkAsmHexNum();
        }
        break;
      case 193:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1592: TkAsmHexLabel
        {
          mTkAsmHexLabel();
        }
        break;
      case 194:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1606: QuotedString
        {
          mQuotedString();
        }
        break;
      case 195:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1619: ControlString
        {
          mControlString();
        }
        break;
      case 196:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1633: COMMENT
        {
          mCOMMENT();
        }
        break;
      case 197:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1641: WS
        {
          mWS();
        }
        break;
      case 198:
        // ***REMOVED***\\Utilities\\sonar-delphi\\src\\main\\antlr3\\org\\sonar\\plugins\\delphi\\antlr\\Delphi.g:1:1644: UnicodeBOM
        {
          mUnicodeBOM();
        }
        break;
    }
  }

  protected DFA18 dfa18 = new DFA18(this);
  static final String DFA18_eotS =
      "\1\uffff\25\64\3\uffff\1\u008a\1\u008c\3\uffff\1\u008f\1\u0091\1\u0093"
          + "\3\uffff\1\u0096\2\uffff\1\u0097\2\uffff\12\64\1\uffff\1\64\1\u00a5\1"
          + "\u00a6\4\uffff\4\64\1\u00b3\1\u00b4\4\64\1\u00b6\1\u00b7\1\uffff\10\64"
          + "\1\u00c4\1\u00c5\1\u00c6\12\64\1\u00d6\1\64\1\u00dd\1\u00de\12\64\1\u00ea"
          + "\1\u00eb\1\64\1\u00ed\16\64\1\u010c\12\64\17\uffff\15\64\2\uffff\1\u00a6"
          + "\4\uffff\1\64\1\u012a\1\u012b\2\64\1\u012e\1\64\2\uffff\1\64\2\uffff\12"
          + "\64\1\u013c\1\64\3\uffff\2\64\1\u0140\4\64\1\u0146\3\64\1\u014b\3\64\1"
          + "\uffff\6\64\2\uffff\4\64\1\u0159\2\64\1\u015c\1\64\1\u015e\1\64\2\uffff"
          + "\1\64\1\uffff\1\u0161\24\64\1\u017a\1\u017b\1\u017c\6\64\1\uffff\1\u0183"
          + "\6\64\1\u018c\4\64\1\u0191\15\64\1\u00a8\2\64\2\uffff\2\64\1\uffff\4\64"
          + "\1\u01a8\10\64\1\uffff\2\64\1\u01b4\1\uffff\1\64\1\u01b6\3\64\1\uffff"
          + "\1\64\1\u01bb\2\64\1\uffff\1\64\1\u01bf\13\64\1\uffff\1\u01cb\1\u01cc"
          + "\1\uffff\1\64\1\uffff\2\64\1\uffff\14\64\1\u01df\13\64\3\uffff\4\64\1"
          + "\u01f0\1\64\1\uffff\1\u01f2\1\u01f3\1\u01f4\2\64\1\u01f7\2\64\1\uffff"
          + "\2\64\1\u01fc\1\64\1\uffff\15\64\1\u00a8\3\64\1\u020e\2\64\1\u0211\1\u0212"
          + "\1\uffff\1\u0213\1\u0214\1\u0216\10\64\1\uffff\1\64\1\uffff\3\64\1\u0224"
          + "\1\uffff\1\u0227\2\64\1\uffff\2\64\1\u022c\4\64\1\u0231\1\64\1\u0233\1"
          + "\64\2\uffff\20\64\1\u0246\1\64\1\uffff\20\64\1\uffff\1\64\3\uffff\1\64"
          + "\1\u025a\1\uffff\3\64\1\u025e\1\uffff\1\u0260\3\64\1\u0265\14\64\1\uffff"
          + "\2\64\4\uffff\1\64\1\uffff\5\64\1\u027a\1\64\1\u027c\1\64\1\u027e\1\64"
          + "\1\u0281\1\64\1\uffff\2\64\1\uffff\2\64\1\u0287\1\64\1\uffff\2\64\1\u028b"
          + "\1\64\1\uffff\1\64\1\uffff\2\64\1\u0290\4\64\1\u0295\1\u0296\7\64\1\u029e"
          + "\1\64\1\uffff\1\64\1\u02a1\3\64\1\u02a5\1\u02a6\4\64\1\u02ab\1\u02ac\1"
          + "\64\1\u02ae\1\u02af\1\u02b0\1\64\1\u02b2\1\uffff\3\64\1\uffff\1\64\1\uffff"
          + "\4\64\1\uffff\21\64\1\u02cf\2\64\1\uffff\1\64\1\uffff\1\u02d3\1\uffff"
          + "\1\64\1\u02d5\1\uffff\2\64\1\u02d8\1\u02d9\1\64\1\uffff\3\64\1\uffff\1"
          + "\64\1\u02df\1\u02e0\1\64\1\uffff\3\64\1\u02e5\2\uffff\1\64\1\u02e7\1\u02e8"
          + "\1\64\1\u02ea\2\64\1\uffff\2\64\1\uffff\3\64\2\uffff\4\64\2\uffff\1\u02f6"
          + "\3\uffff\1\64\1\uffff\1\u02f8\1\u02f9\1\u02fa\20\64\1\u030c\1\u030d\2"
          + "\64\1\u0310\2\64\1\u0313\1\u0314\1\uffff\3\64\1\uffff\1\64\1\uffff\1\u0319"
          + "\1\64\2\uffff\1\u031b\4\64\2\uffff\1\64\1\u0321\1\u0322\1\u0323\1\uffff"
          + "\1\u0324\2\uffff\1\64\1\uffff\1\u0326\2\64\1\u0329\1\64\1\u032b\1\64\1"
          + "\u032d\1\u032e\1\64\1\u0330\1\uffff\1\64\3\uffff\7\64\1\u033a\11\64\2"
          + "\uffff\1\64\1\u0345\1\uffff\1\u0346\1\64\2\uffff\4\64\1\uffff\1\64\1\uffff"
          + "\1\64\1\u034f\1\64\1\u0351\1\u0352\4\uffff\1\u0353\1\uffff\1\u0354\1\u0355"
          + "\1\uffff\1\u0356\1\uffff\1\64\2\uffff\1\64\1\uffff\1\u0359\1\u035a\7\64"
          + "\1\uffff\11\64\1\u0372\2\uffff\1\64\1\u0374\1\u0375\4\64\1\u037a\1\uffff"
          + "\1\64\6\uffff\2\64\2\uffff\27\64\1\uffff\1\u0396\2\uffff\4\64\1\uffff"
          + "\1\64\1\u039c\12\64\1\u03a7\2\64\1\u03aa\3\64\1\u03ae\7\64\1\uffff\1\64"
          + "\1\u03b7\1\u03b8\2\64\1\uffff\12\64\1\uffff\2\64\1\uffff\3\64\1\uffff"
          + "\7\64\1\u03d1\2\uffff\4\64\1\u03d6\1\u03d7\1\u03d8\1\64\1\u03da\1\64\1"
          + "\u03dc\1\u03dd\1\u03de\1\u03df\1\u03e0\2\64\1\u03e3\6\64\1\uffff\1\u03ea"
          + "\1\u03eb\1\u03ec\1\64\3\uffff\1\64\1\uffff\1\64\5\uffff\1\u03f0\1\u03f1"
          + "\1\uffff\1\64\1\u03f3\4\64\3\uffff\1\u03f8\1\u03f9\1\64\2\uffff\1\u03fb"
          + "\1\uffff\4\64\2\uffff\1\u0401\1\uffff\5\64\1\uffff\3\64\1\u040b\3\64\1"
          + "\u040f\1\64\1\uffff\3\64\1\uffff\2\64\1\u0416\2\64\1\u0419\1\uffff\2\64"
          + "\1\uffff\1\u041c\1\64\1\uffff\1\u041e\1\uffff";
  static final String DFA18_eofS = "\u041f\uffff";
  static final String DFA18_minS =
      "\1\11\6\60\1\157\1\145\1\146\1\141\1\145\1\141\1\142\3\141\1\150\1\156"
          + "\1\141\1\150\1\157\3\uffff\1\57\1\75\3\uffff\2\75\1\52\3\uffff\1\51\2"
          + "\uffff\1\0\2\uffff\2\60\2\105\1\116\1\102\1\101\3\60\1\uffff\1\60\1\0"
          + "\1\56\4\uffff\2\60\1\144\1\162\2\60\1\164\5\60\1\uffff\1\60\1\145\2\60"
          + "\1\141\1\156\1\60\1\163\3\60\1\156\1\163\1\144\1\143\1\60\1\154\1\162"
          + "\1\156\1\164\1\154\1\60\1\160\2\60\2\142\1\143\1\163\1\144\1\155\1\141"
          + "\1\154\1\144\1\152\2\60\1\145\1\60\1\164\1\145\1\143\1\141\2\151\1\142"
          + "\1\151\1\141\1\146\1\141\1\154\1\141\1\145\1\60\1\165\1\160\1\151\1\145"
          + "\2\162\1\151\1\164\1\151\1\162\17\uffff\2\116\1\123\1\101\1\127\1\103"
          + "\1\124\1\112\1\122\1\117\1\123\1\117\1\103\2\uffff\1\56\1\uffff\1\53\1"
          + "\60\1\uffff\1\157\2\60\1\151\1\141\1\60\1\145\2\uffff\1\157\2\0\1\151"
          + "\1\141\1\145\1\60\2\163\1\60\1\162\1\164\1\160\1\60\1\156\3\uffff\1\141"
          + "\1\145\1\60\1\145\1\164\2\145\1\60\1\163\1\145\1\141\1\60\1\143\1\157"
          + "\1\160\1\uffff\1\154\2\145\1\164\1\151\1\145\2\uffff\1\145\1\162\1\141"
          + "\1\163\1\60\1\145\1\162\1\60\1\145\1\60\1\145\2\uffff\1\162\1\uffff\1"
          + "\60\1\162\1\153\1\143\1\164\1\156\1\166\1\143\1\154\1\163\1\144\1\157"
          + "\1\145\1\151\1\156\1\157\1\145\1\165\1\151\1\145\1\154\3\60\1\164\1\143"
          + "\1\162\1\151\1\156\1\145\1\uffff\1\60\2\145\1\164\1\141\1\151\1\163\1"
          + "\60\1\164\1\154\1\150\1\164\1\60\1\103\1\123\1\124\1\123\1\137\1\117\2"
          + "\105\1\111\1\116\1\105\1\103\1\105\1\60\1\154\1\162\2\uffff\1\163\1\171"
          + "\1\uffff\2\155\1\156\1\153\2\60\1\163\1\164\1\141\1\60\1\145\1\162\1\151"
          + "\1\uffff\1\164\1\155\1\60\1\uffff\1\160\1\60\3\162\1\uffff\1\145\1\60"
          + "\1\154\1\141\1\uffff\1\164\1\60\2\145\1\170\1\162\1\151\1\156\1\162\1"
          + "\154\1\141\1\154\1\141\1\uffff\2\60\1\uffff\1\146\1\uffff\1\143\1\141"
          + "\1\uffff\1\154\2\141\1\146\1\164\1\141\1\145\1\162\2\145\1\151\1\145\1"
          + "\60\2\162\1\163\1\164\1\166\1\141\1\151\1\144\1\165\1\143\1\145\3\uffff"
          + "\1\151\1\141\1\145\1\143\1\60\1\141\1\uffff\3\60\1\146\1\154\1\60\1\162"
          + "\1\141\1\uffff\1\165\1\145\1\60\1\145\1\uffff\2\124\1\117\1\123\1\124"
          + "\2\122\1\103\1\101\1\131\1\115\1\113\1\120\1\60\1\165\1\141\1\164\1\60"
          + "\1\142\1\141\2\60\1\uffff\3\60\1\151\1\156\1\154\1\143\1\165\1\144\1\157"
          + "\1\151\1\uffff\1\164\1\uffff\1\151\1\164\1\156\1\60\1\uffff\1\60\1\162"
          + "\1\151\1\uffff\1\162\1\155\1\60\1\151\1\141\1\145\1\146\1\60\1\162\1\60"
          + "\1\147\2\uffff\1\141\2\164\1\157\1\151\1\147\1\144\1\154\1\157\1\145\1"
          + "\164\1\144\1\141\1\162\2\143\1\60\1\156\1\uffff\1\144\1\145\1\164\1\162"
          + "\1\145\1\164\1\162\1\145\1\162\1\141\1\144\1\143\1\154\1\144\1\164\1\147"
          + "\1\uffff\1\144\3\uffff\1\145\1\60\1\uffff\1\147\1\156\1\141\1\60\1\uffff"
          + "\1\60\1\111\1\101\1\115\1\60\1\131\1\104\1\106\1\124\1\102\1\115\1\102"
          + "\1\137\1\124\1\164\1\143\1\162\1\uffff\1\154\1\164\4\uffff\1\165\1\uffff"
          + "\1\156\1\165\1\164\1\141\1\143\1\60\1\164\1\60\1\143\1\60\1\155\1\60\1"
          + "\141\1\uffff\1\172\1\171\1\uffff\1\144\1\157\1\60\1\145\1\uffff\1\164"
          + "\1\154\1\60\1\141\1\uffff\1\171\1\uffff\1\145\1\165\1\60\1\157\1\141\1"
          + "\144\1\145\2\60\2\162\1\145\1\165\1\155\2\164\1\60\1\150\1\uffff\1\154"
          + "\1\60\1\156\1\145\1\157\2\60\1\145\1\156\1\143\1\154\2\60\1\154\3\60\1"
          + "\166\1\60\1\uffff\1\163\1\164\1\154\1\uffff\1\156\1\uffff\1\117\1\116"
          + "\1\137\1\106\1\uffff\1\120\1\137\1\101\1\137\1\114\1\117\1\114\1\104\1"
          + "\111\1\145\1\164\1\151\2\145\1\143\1\163\1\145\1\60\2\164\1\uffff\1\145"
          + "\1\uffff\1\60\1\uffff\1\145\1\60\1\uffff\1\154\1\141\2\60\1\156\1\uffff"
          + "\1\156\1\145\1\151\1\uffff\1\143\2\60\1\154\1\uffff\1\162\1\144\1\145"
          + "\1\60\2\uffff\1\155\2\60\1\162\1\60\1\171\1\145\1\uffff\1\145\1\171\1"
          + "\uffff\1\143\1\162\1\144\2\uffff\1\163\1\164\1\145\1\154\2\uffff\1\60"
          + "\3\uffff\1\141\1\uffff\3\60\1\154\1\116\1\124\1\101\1\106\1\101\1\111"
          + "\1\105\1\110\1\103\1\124\1\105\1\125\2\105\1\117\2\60\1\156\1\162\1\60"
          + "\1\144\1\164\2\60\1\uffff\1\145\1\157\1\162\1\uffff\1\156\1\uffff\1\60"
          + "\1\164\2\uffff\1\60\1\164\1\144\1\172\1\145\2\uffff\1\164\3\60\1\uffff"
          + "\1\60\2\uffff\1\145\1\uffff\1\60\2\144\1\60\1\145\1\60\1\165\2\60\1\163"
          + "\1\60\1\uffff\1\162\3\uffff\1\171\2\137\1\124\1\137\1\122\1\105\1\60\1"
          + "\131\2\105\1\131\1\137\1\123\1\122\1\103\1\116\2\uffff\1\147\1\60\1\uffff"
          + "\1\60\1\157\2\uffff\1\144\1\162\1\146\1\164\1\uffff\1\151\1\uffff\1\141"
          + "\1\60\1\141\2\60\4\uffff\1\60\1\uffff\2\60\1\uffff\1\60\1\uffff\1\143"
          + "\2\uffff\1\164\1\uffff\2\60\1\101\1\116\2\124\1\105\1\114\1\104\1\uffff"
          + "\1\120\1\114\1\137\1\120\1\111\2\137\1\114\1\137\1\60\2\uffff\1\162\2"
          + "\60\2\141\1\157\1\164\1\60\1\uffff\1\164\6\uffff\1\145\1\162\2\uffff\1"
          + "\114\1\101\1\122\1\117\1\105\1\101\1\122\1\131\1\116\1\104\1\101\2\105"
          + "\1\120\1\107\1\105\1\131\1\104\1\101\1\105\1\111\1\137\1\110\1\uffff\1"
          + "\60\2\uffff\1\143\1\154\1\156\1\151\1\uffff\1\151\1\60\1\151\1\117\1\115"
          + "\1\107\1\104\1\124\1\115\1\111\1\120\1\124\1\60\1\115\1\103\1\60\1\105"
          + "\1\131\1\125\1\60\1\120\1\105\1\122\1\130\1\116\1\123\1\101\1\uffff\1"
          + "\145\2\60\2\157\1\uffff\1\156\1\102\1\105\1\123\1\131\1\125\1\105\1\102"
          + "\1\105\1\123\1\uffff\1\105\1\114\1\uffff\1\122\1\120\1\111\1\uffff\1\105"
          + "\1\116\1\101\1\120\1\123\1\105\1\116\1\60\2\uffff\2\156\1\147\1\101\3"
          + "\60\1\122\1\60\1\125\5\60\1\105\1\104\1\60\1\124\1\115\1\122\1\124\1\103"
          + "\1\104\1\uffff\3\60\1\114\3\uffff\1\116\1\uffff\1\124\5\uffff\2\60\1\uffff"
          + "\1\123\1\60\1\105\1\122\1\124\1\114\3\uffff\2\60\1\105\2\uffff\1\60\1"
          + "\uffff\1\123\1\125\1\111\1\105\2\uffff\1\60\1\uffff\1\123\1\103\1\117"
          + "\1\122\1\101\1\uffff\1\111\1\124\1\116\1\60\1\122\1\117\1\111\1\60\1\111"
          + "\1\uffff\1\107\1\116\1\117\1\uffff\1\104\1\123\1\60\1\116\1\105\1\60\1"
          + "\uffff\1\123\1\116\1\uffff\1\60\1\124\1\uffff\1\60\1\uffff";
  static final String DFA18_maxS =
      "\1\ufffe\1\165\1\162\1\157\1\171\1\170\1\165\1\157\1\145\1\163\3\157\1"
          + "\166\1\165\1\145\1\164\1\171\1\163\1\151\1\162\1\157\3\uffff\1\57\1\75"
          + "\3\uffff\1\76\1\75\1\56\3\uffff\1\56\2\uffff\1\uffff\2\uffff\2\150\2\105"
          + "\1\116\1\102\1\101\3\150\1\uffff\1\150\1\uffff\1\150\4\uffff\1\163\1\150"
          + "\1\163\1\162\2\ufffe\1\164\3\150\2\ufffe\1\uffff\1\150\1\145\1\163\1\150"
          + "\1\141\1\156\1\163\1\166\3\ufffe\1\156\1\163\1\144\1\164\1\162\1\156\1"
          + "\162\1\156\1\164\1\154\1\ufffe\1\160\2\ufffe\2\142\1\143\1\163\1\144\1"
          + "\155\1\141\1\154\1\164\1\152\2\ufffe\1\145\1\ufffe\1\164\1\145\1\163\1"
          + "\141\1\151\1\157\1\142\1\151\1\163\1\146\1\164\3\162\1\ufffe\1\171\1\160"
          + "\1\164\1\145\2\162\1\151\1\164\1\151\1\162\17\uffff\2\116\1\123\1\101"
          + "\1\127\1\103\1\124\1\112\1\122\1\117\1\123\1\117\1\103\2\uffff\1\150\1"
          + "\uffff\2\150\1\uffff\1\164\2\ufffe\1\151\1\141\1\ufffe\1\145\2\uffff\1"
          + "\157\2\0\1\151\1\141\1\145\1\150\1\163\1\164\1\150\1\162\1\164\1\160\1"
          + "\ufffe\1\156\3\uffff\1\141\1\145\1\ufffe\1\145\1\164\1\157\1\145\1\ufffe"
          + "\1\163\1\145\1\141\1\ufffe\1\143\1\157\1\160\1\uffff\1\154\2\145\1\164"
          + "\1\151\1\145\2\uffff\1\145\1\162\1\141\1\163\1\ufffe\1\145\1\162\1\ufffe"
          + "\1\145\1\ufffe\1\145\2\uffff\1\162\1\uffff\1\ufffe\1\162\1\153\1\143\1"
          + "\164\1\156\1\166\1\164\1\154\1\163\1\144\1\157\1\145\1\151\1\156\1\157"
          + "\1\145\1\165\1\157\1\145\1\154\3\ufffe\1\164\1\143\1\162\1\151\1\156\1"
          + "\145\1\uffff\1\ufffe\2\145\1\164\1\141\1\151\1\163\1\ufffe\1\164\1\154"
          + "\1\150\1\164\1\ufffe\1\103\1\123\1\124\1\123\1\137\1\117\2\105\1\111\1"
          + "\116\1\105\1\103\1\105\1\150\1\154\1\162\2\uffff\1\163\1\171\1\uffff\2"
          + "\155\1\156\1\153\1\ufffe\1\154\1\163\1\164\1\151\1\165\1\145\1\162\1\151"
          + "\1\uffff\1\164\1\155\1\ufffe\1\uffff\1\160\1\ufffe\3\162\1\uffff\1\145"
          + "\1\ufffe\1\154\1\141\1\uffff\1\164\1\ufffe\2\145\1\170\1\162\1\151\1\156"
          + "\1\162\1\154\1\141\1\154\1\141\1\uffff\2\ufffe\1\uffff\1\146\1\uffff\1"
          + "\143\1\141\1\uffff\1\162\1\145\1\141\1\146\1\164\1\141\1\145\1\162\2\145"
          + "\1\151\1\145\1\ufffe\2\162\1\163\1\164\1\166\1\141\1\151\1\144\1\165\1"
          + "\143\1\145\3\uffff\1\151\1\141\1\145\1\156\1\ufffe\1\141\1\uffff\3\ufffe"
          + "\1\146\1\154\1\ufffe\1\162\1\141\1\uffff\1\165\1\145\1\ufffe\1\145\1\uffff"
          + "\2\124\1\117\1\123\1\124\2\122\1\103\1\101\1\131\1\115\1\113\1\120\1\150"
          + "\1\165\1\141\1\164\1\ufffe\1\142\1\141\2\ufffe\1\uffff\3\ufffe\1\151\1"
          + "\156\1\154\1\143\1\165\1\156\1\157\1\151\1\uffff\1\164\1\uffff\1\151\1"
          + "\164\1\156\1\ufffe\1\uffff\1\ufffe\1\162\1\151\1\uffff\1\162\1\155\1\ufffe"
          + "\1\151\1\141\1\145\1\146\1\ufffe\1\162\1\ufffe\1\147\2\uffff\1\141\2\164"
          + "\1\157\1\151\1\147\1\144\1\154\1\157\1\145\1\164\1\144\1\141\1\162\1\143"
          + "\1\163\1\ufffe\1\156\1\uffff\1\144\1\145\1\164\1\162\1\145\1\164\1\162"
          + "\1\145\1\162\1\141\1\144\1\143\1\154\1\144\1\164\1\147\1\uffff\1\144\3"
          + "\uffff\1\145\1\ufffe\1\uffff\1\147\1\156\1\141\1\ufffe\1\uffff\1\ufffe"
          + "\1\111\1\101\1\115\1\ufffe\1\131\1\104\1\106\1\124\1\102\1\115\1\102\1"
          + "\137\1\124\1\164\1\143\1\162\1\uffff\1\154\1\164\4\uffff\1\165\1\uffff"
          + "\1\156\1\165\1\164\1\141\1\143\1\ufffe\1\164\1\ufffe\1\143\1\ufffe\1\155"
          + "\1\ufffe\1\141\1\uffff\1\172\1\171\1\uffff\1\144\1\157\1\ufffe\1\145\1"
          + "\uffff\1\164\1\154\1\ufffe\1\141\1\uffff\1\171\1\uffff\1\145\1\165\1\ufffe"
          + "\1\157\1\141\1\144\1\145\2\ufffe\2\162\1\145\1\165\1\155\2\164\1\ufffe"
          + "\1\150\1\uffff\1\154\1\ufffe\1\156\1\145\1\157\2\ufffe\1\145\1\156\1\143"
          + "\1\154\2\ufffe\1\154\3\ufffe\1\166\1\ufffe\1\uffff\1\163\1\164\1\154\1"
          + "\uffff\1\156\1\uffff\1\117\1\116\1\137\1\120\1\uffff\1\120\1\137\1\101"
          + "\1\137\1\114\1\117\1\114\1\104\1\111\1\145\1\164\1\151\1\171\1\145\1\143"
          + "\1\163\1\145\1\ufffe\2\164\1\uffff\1\145\1\uffff\1\ufffe\1\uffff\1\145"
          + "\1\ufffe\1\uffff\1\154\1\141\2\ufffe\1\156\1\uffff\1\156\1\145\1\151\1"
          + "\uffff\1\143\2\ufffe\1\154\1\uffff\1\162\1\144\1\145\1\ufffe\2\uffff\1"
          + "\155\2\ufffe\1\162\1\ufffe\1\171\1\145\1\uffff\1\145\1\171\1\uffff\1\143"
          + "\1\162\1\144\2\uffff\1\163\1\164\1\145\1\154\2\uffff\1\ufffe\3\uffff\1"
          + "\141\1\uffff\3\ufffe\1\154\1\116\1\124\1\101\1\106\1\101\1\111\1\105\1"
          + "\124\1\103\1\124\1\105\1\125\2\105\1\117\2\ufffe\1\156\1\162\1\ufffe\1"
          + "\144\1\164\2\ufffe\1\uffff\1\145\1\157\1\162\1\uffff\1\156\1\uffff\1\ufffe"
          + "\1\164\2\uffff\1\ufffe\1\164\1\144\1\172\1\145\2\uffff\1\164\3\ufffe\1"
          + "\uffff\1\ufffe\2\uffff\1\145\1\uffff\1\ufffe\2\144\1\ufffe\1\145\1\ufffe"
          + "\1\165\2\ufffe\1\163\1\ufffe\1\uffff\1\162\3\uffff\1\171\2\137\1\124\1"
          + "\137\1\122\1\105\1\ufffe\1\131\2\105\1\131\1\137\1\123\1\122\1\103\1\116"
          + "\2\uffff\1\147\1\ufffe\1\uffff\1\ufffe\1\157\2\uffff\1\144\1\162\1\146"
          + "\1\164\1\uffff\1\151\1\uffff\1\163\1\ufffe\1\141\2\ufffe\4\uffff\1\ufffe"
          + "\1\uffff\2\ufffe\1\uffff\1\ufffe\1\uffff\1\143\2\uffff\1\164\1\uffff\2"
          + "\ufffe\1\122\1\116\2\124\1\105\1\114\1\116\1\uffff\1\120\1\114\1\137\1"
          + "\120\1\124\2\137\1\114\1\137\1\ufffe\2\uffff\1\162\2\ufffe\2\141\1\157"
          + "\1\164\1\ufffe\1\uffff\1\164\6\uffff\1\145\1\162\2\uffff\1\114\1\101\1"
          + "\122\1\117\1\105\1\101\1\122\1\131\1\116\1\104\1\101\2\105\1\120\1\124"
          + "\1\105\1\131\1\104\1\101\1\105\1\111\1\137\1\110\1\uffff\1\ufffe\2\uffff"
          + "\1\143\1\154\1\156\1\151\1\uffff\1\151\1\ufffe\1\151\1\117\1\115\1\107"
          + "\1\104\1\124\1\115\1\111\1\120\1\124\1\ufffe\1\115\1\103\1\ufffe\1\105"
          + "\1\131\1\125\1\ufffe\1\120\1\105\1\122\1\130\1\116\1\123\1\101\1\uffff"
          + "\1\145\2\ufffe\2\157\1\uffff\1\156\1\102\1\105\1\123\1\131\1\125\1\105"
          + "\1\102\1\105\1\123\1\uffff\1\105\1\114\1\uffff\1\122\1\120\1\111\1\uffff"
          + "\1\105\1\116\1\101\1\120\1\123\1\105\1\116\1\ufffe\2\uffff\2\156\1\147"
          + "\1\101\3\ufffe\1\122\1\ufffe\1\125\5\ufffe\1\105\1\104\1\ufffe\1\124\1"
          + "\115\1\122\1\124\1\103\1\104\1\uffff\3\ufffe\1\114\3\uffff\1\116\1\uffff"
          + "\1\124\5\uffff\2\ufffe\1\uffff\1\123\1\ufffe\1\105\1\122\1\124\1\114\3"
          + "\uffff\2\ufffe\1\105\2\uffff\1\ufffe\1\uffff\1\123\1\125\1\111\1\105\2"
          + "\uffff\1\ufffe\1\uffff\1\123\1\103\1\117\1\122\1\101\1\uffff\1\111\1\124"
          + "\1\116\1\ufffe\1\122\1\117\1\111\1\ufffe\1\111\1\uffff\1\107\1\116\1\117"
          + "\1\uffff\1\104\1\123\1\ufffe\1\116\1\105\1\ufffe\1\uffff\1\123\1\116\1"
          + "\uffff\1\ufffe\1\124\1\uffff\1\ufffe\1\uffff";
  static final String DFA18_acceptS =
      "\26\uffff\1\u0085\1\u0086\1\u0087\2\uffff\1\u008a\1\u008b\1\u008d\3\uffff"
          + "\1\u0094\1\u0095\1\u0097\1\uffff\1\u0099\1\u009a\1\uffff\1\u009e\1\u009f"
          + "\12\uffff\1\u00bc\3\uffff\1\u00bf\1\u00c2\1\u00c3\1\u00c5\14\uffff\1\u00c1"
          + "\100\uffff\1\u00c4\1\u0088\1\u0089\1\u008c\1\u008e\1\u0090\1\u008f\1\u0091"
          + "\1\u0092\1\u0096\1\u0093\1\u0098\1\u009c\1\u009b\1\u009d\15\uffff\1\u00c6"
          + "\1\u00bd\1\uffff\1\u00be\2\uffff\1\u00c0\7\uffff\1\7\1\13\17\uffff\1\34"
          + "\1\36\1\37\17\uffff\1\63\6\uffff\1\66\1\74\13\uffff\1\110\1\111\1\uffff"
          + "\1\113\36\uffff\1\163\35\uffff\1\3\1\4\2\uffff\1\10\15\uffff\1\33\3\uffff"
          + "\1\42\5\uffff\1\51\4\uffff\1\56\15\uffff\1\101\2\uffff\1\104\1\uffff\1"
          + "\106\2\uffff\1\114\30\uffff\1\151\1\152\1\153\6\uffff\1\164\10\uffff\1"
          + "\172\4\uffff\1\u0082\26\uffff\1\17\13\uffff\1\41\1\uffff\1\44\4\uffff"
          + "\1\52\3\uffff\1\61\13\uffff\1\102\1\103\22\uffff\1\134\20\uffff\1\161"
          + "\1\uffff\1\u0084\1\165\1\166\2\uffff\1\171\4\uffff\1\177\21\uffff\1\6"
          + "\2\uffff\1\15\1\16\1\20\1\21\1\uffff\1\22\15\uffff\1\u0083\2\uffff\1\53"
          + "\4\uffff\1\67\4\uffff\1\75\1\uffff\1\77\22\uffff\1\133\23\uffff\1\170"
          + "\3\uffff\1\176\1\uffff\1\u0080\4\uffff\1\u00ab\24\uffff\1\31\1\uffff\1"
          + "\35\1\uffff\1\43\2\uffff\1\46\5\uffff\1\62\3\uffff\1\72\4\uffff\1\107"
          + "\4\uffff\1\120\1\121\7\uffff\1\131\2\uffff\1\136\3\uffff\1\142\1\143\4"
          + "\uffff\1\150\1\154\1\uffff\1\156\1\157\1\160\1\uffff\1\167\34\uffff\1"
          + "\26\3\uffff\1\40\1\uffff\1\47\2\uffff\1\55\1\57\5\uffff\1\76\1\100\4\uffff"
          + "\1\117\1\uffff\1\123\1\124\1\uffff\1\126\13\uffff\1\155\1\uffff\1\173"
          + "\1\174\1\175\21\uffff\1\1\1\2\2\uffff\1\12\2\uffff\1\24\1\25\4\uffff\1"
          + "\50\1\uffff\1\60\5\uffff\1\112\1\115\1\116\1\122\1\uffff\1\127\2\uffff"
          + "\1\135\1\uffff\1\140\1\uffff\1\144\1\145\1\uffff\1\147\11\uffff\1\u00a8"
          + "\12\uffff\1\11\1\14\10\uffff\1\70\1\uffff\1\73\1\105\1\125\1\130\1\132"
          + "\1\137\2\uffff\1\162\1\u0081\27\uffff\1\5\1\uffff\1\27\1\30\4\uffff\1"
          + "\65\33\uffff\1\23\5\uffff\1\141\12\uffff\1\u00b6\2\uffff\1\u00ac\3\uffff"
          + "\1\u00af\10\uffff\1\45\1\54\30\uffff\1\32\4\uffff\1\u00a1\1\u00a3\1\u00a4"
          + "\1\uffff\1\u00a2\1\uffff\1\u00b0\1\u00b5\1\u00a9\1\u00aa\1\u00ad\2\uffff"
          + "\1\u00b1\6\uffff\1\64\1\71\1\146\3\uffff\1\u00ae\1\u00b4\1\uffff\1\u00b3"
          + "\4\uffff\1\u00a0\1\u00a5\1\uffff\1\u00b2\5\uffff\1\u00a6\11\uffff\1\u00bb"
          + "\3\uffff\1\u00b9\6\uffff\1\u00b7\2\uffff\1\u00a7\2\uffff\1\u00b8\1\uffff"
          + "\1\u00ba";
  static final String DFA18_specialS =
      "\1\uffff\1\33\1\17\1\37\1\20\1\36\1\41\40\uffff\1\1\2\uffff\1\11\1\23"
          + "\5\uffff\1\44\1\43\1\2\1\uffff\1\42\1\40\1\14\4\uffff\1\35\1\22\5\uffff"
          + "\1\12\1\13\1\7\3\uffff\1\24\1\uffff\1\25\1\26\2\uffff\1\10\10\uffff\1"
          + "\21\116\uffff\1\16\1\uffff\1\34\1\0\2\uffff\1\3\10\uffff\1\5\1\6\3\uffff"
          + "\1\30\2\uffff\1\32\150\uffff\1\4\14\uffff\1\27\3\uffff\1\31\146\uffff"
          + "\1\15\u027f\uffff}>";
  static final String[] DFA18_transitionS = {
    "\2\73\1\uffff\2\73\22\uffff\1\73\2\uffff\1\72\1\70\1\uffff\1\51\1\71"
        + "\1\40\1\41\1\30\1\26\1\33\1\27\1\44\1\31\12\67\1\32\1\34\1\36\1\35\1"
        + "\37\1\uffff\1\46\1\61\1\62\1\53\1\65\1\63\1\52\2\64\1\56\4\64\1\54\1"
        + "\57\2\64\1\55\3\64\1\60\4\64\1\42\1\uffff\1\43\1\45\1\64\1\uffff\1\1"
        + "\1\2\1\3\1\4\1\5\1\6\1\7\1\10\1\11\2\64\1\12\1\13\1\14\1\15\1\16\1\64"
        + "\1\17\1\20\1\21\1\22\1\23\1\24\1\25\2\64\1\47\1\uffff\1\50\2\uffff\ufe7f"
        + "\64\1\66\u00ff\64",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\1\103\1\74\1\103"
        + "\1\75\2\103\1\uffff\1\106\5\uffff\1\76\3\uffff\1\77\1\100\1\101\1\102",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\4\103\1\111\1\103"
        + "\1\uffff\1\106\11\uffff\1\112",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\1\113\2\103\1\114"
        + "\2\103\1\uffff\1\106\3\uffff\1\115\2\uffff\1\116",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\4\103\1\117\1\103"
        + "\1\uffff\1\106\1\120\5\uffff\1\121\1\uffff\1\122\5\uffff\1\123\1\uffff"
        + "\1\124",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\6\103\1\uffff\1\106"
        + "\3\uffff\1\125\1\uffff\1\126\11\uffff\1\127",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\1\130\5\103\1\uffff"
        + "\1\106\1\131\5\uffff\1\132\5\uffff\1\133",
    "\1\134",
    "\1\135",
    "\1\136\6\uffff\1\137\1\140\4\uffff\1\141",
    "\1\142\7\uffff\1\143\5\uffff\1\144",
    "\1\145\11\uffff\1\146",
    "\1\147\3\uffff\1\150\3\uffff\1\151\5\uffff\1\152",
    "\1\153\3\uffff\1\154\7\uffff\1\155\1\uffff\1\156\1\uffff\1\157\2\uffff" + "\1\160\1\161",
    "\1\162\12\uffff\1\163\2\uffff\1\164\2\uffff\1\165\2\uffff\1\166",
    "\1\167\3\uffff\1\170",
    "\1\171\3\uffff\1\172\2\uffff\1\173\13\uffff\1\174",
    "\1\175\6\uffff\1\176\2\uffff\1\177\6\uffff\1\u0080",
    "\1\u0081\4\uffff\1\u0082",
    "\1\u0083\7\uffff\1\u0084",
    "\1\u0085\1\u0086\10\uffff\1\u0087",
    "\1\u0088",
    "",
    "",
    "",
    "\1\u0089",
    "\1\u008b",
    "",
    "",
    "",
    "\1\u008e\1\u008d",
    "\1\u0090",
    "\1\u0089\3\uffff\1\u0092",
    "",
    "",
    "",
    "\1\u0094\4\uffff\1\u0095",
    "",
    "",
    "\0\u0089",
    "",
    "",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\14\uffff\1\u0098\13\uffff" + "\6\103\1\uffff\1\106",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\3\uffff\1\u009b\2\uffff\1"
        + "\u0099\5\uffff\1\u009a\13\uffff\6\103\1\uffff\1\106",
    "\1\u009c",
    "\1\u009d",
    "\1\u009e",
    "\1\u009f",
    "\1\u00a0",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\5\uffff\1\u00a1\4\uffff\1"
        + "\u00a2\15\uffff\6\103\1\uffff\1\106",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\3\uffff\1\u00a3\24\uffff\6" + "\103\1\uffff\1\106",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\17\uffff\1\u00a4\10\uffff" + "\6\103\1\uffff\1\106",
    "",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\6\103\1\uffff\1\106",
    "\ufeff\64\1\uffff\u0100\64",
    "\1\u00a8\1\uffff\12\u00a7\1\110\6\uffff\4\u00aa\1\u00a9\1\u00aa\1\uffff"
        + "\1\u00ab\30\uffff\4\u00aa\1\u00a9\1\u00aa\1\uffff\1\u00ab",
    "",
    "",
    "",
    "",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\6\103\1\uffff\1\106" + "\12\uffff\1\u00ac",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\3\103\1\u00ad\2\103" + "\1\uffff\1\106",
    "\1\u00ae\16\uffff\1\u00af",
    "\1\u00b0",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\14\64\1\u00b1\5\64\1\u00b2"
        + "\7\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u00b5",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\6\103\1\uffff\1\106",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\6\103\1\uffff\1\106",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\6\103\1\uffff\1\106",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\6\103\1\u00b8\1\106",
    "\1\u00b9",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\6\103\1\uffff\1\106" + "\12\uffff\1\u00ba",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\4\103\1\u00bb\1\103" + "\1\uffff\1\106",
    "\1\u00bc",
    "\1\u00bd",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\5\103\1\u00be\1\uffff"
        + "\1\106\7\uffff\1\u00bf\2\uffff\1\u00c0",
    "\1\u00c1\2\uffff\1\u00c2",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\26\64\1\u00c3\3\64\5\uffff" + "\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u00c7",
    "\1\u00c8",
    "\1\u00c9",
    "\1\u00ca\5\uffff\1\u00cb\6\uffff\1\u00cc\3\uffff\1\u00cd",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\6\103\1\uffff\1\106"
        + "\3\uffff\1\u00cf\5\uffff\1\u00ce",
    "\1\u00d0\1\uffff\1\u00d1",
    "\1\u00d2",
    "\1\u00d3",
    "\1\u00d4",
    "\1\u00d5",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u00d7",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\3\64\1\u00d8\3\64\1\u00d9"
        + "\1\u00da\2\64\1\u00db\7\64\1\u00dc\6\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u00df",
    "\1\u00e0",
    "\1\u00e1",
    "\1\u00e2",
    "\1\u00e3",
    "\1\u00e4",
    "\1\u00e5",
    "\1\u00e6",
    "\1\u00e7\17\uffff\1\u00e8",
    "\1\u00e9",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u00ec",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u00ee",
    "\1\u00ef",
    "\1\u00f0\17\uffff\1\u00f1",
    "\1\u00f2",
    "\1\u00f3",
    "\1\u00f4\5\uffff\1\u00f5",
    "\1\u00f6",
    "\1\u00f7",
    "\1\u00f8\1\uffff\1\u00f9\2\uffff\1\u00fa\1\u00fb\1\uffff\1\u00fc\3\uffff"
        + "\1\u00fd\2\uffff\1\u00fe\1\u00ff\1\uffff\1\u0100",
    "\1\u0101",
    "\1\u0102\22\uffff\1\u0103",
    "\1\u0104\5\uffff\1\u0105",
    "\1\u0106\2\uffff\1\u0107\12\uffff\1\u0108\2\uffff\1\u0109",
    "\1\u010a\14\uffff\1\u010b",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u010e\3\uffff\1\u010d",
    "\1\u010f",
    "\1\u0110\11\uffff\1\u0111\1\u0112",
    "\1\u0113",
    "\1\u0114",
    "\1\u0115",
    "\1\u0116",
    "\1\u0117",
    "\1\u0118",
    "\1\u0119",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\1\u011a",
    "\1\u011b",
    "\1\u011c",
    "\1\u011d",
    "\1\u011e",
    "\1\u011f",
    "\1\u0120",
    "\1\u0121",
    "\1\u0122",
    "\1\u0123",
    "\1\u0124",
    "\1\u0125",
    "\1\u0126",
    "",
    "",
    "\1\u00a8\1\uffff\12\u00a7\1\110\6\uffff\4\u00aa\1\u00a9\1\u00aa\1\uffff"
        + "\1\u00ab\30\uffff\4\u00aa\1\u00a9\1\u00aa\1\uffff\1\u00ab",
    "",
    "\1\u00a8\1\uffff\1\u00a8\2\uffff\12\u0127\1\110\6\uffff\6\u00aa\1\uffff"
        + "\1\u00ab\30\uffff\6\u00aa\1\uffff\1\u00ab",
    "\12\u00aa\1\110\6\uffff\6\u00aa\1\uffff\1\u00ab\30\uffff\6\u00aa\1\uffff" + "\1\u00ab",
    "",
    "\1\u0128\4\uffff\1\u0129",
    "\12\105\1\110\6\uffff\6\104\1\64\1\107\22\64\4\uffff\1\64\1\uffff\6"
        + "\103\1\64\1\106\22\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u012c",
    "\1\u012d",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u012f",
    "",
    "",
    "\1\u0130",
    "\1\uffff",
    "\1\uffff",
    "\1\u0131",
    "\1\u0132",
    "\1\u0133",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\2\103\1\u0134\3\103" + "\1\uffff\1\106",
    "\1\u0135",
    "\1\u0136\1\u0137",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\1\u0138\5\103\1\uffff" + "\1\106",
    "\1\u0139",
    "\1\u013a",
    "\1\u013b",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u013d",
    "",
    "",
    "",
    "\1\u013e",
    "\1\u013f",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0141",
    "\1\u0142",
    "\1\u0143\11\uffff\1\u0144",
    "\1\u0145",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0147",
    "\1\u0148",
    "\1\u0149",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\26\64\1\u014a\3\64\5\uffff" + "\uff7f\64",
    "\1\u014c",
    "\1\u014d",
    "\1\u014e",
    "",
    "\1\u014f",
    "\1\u0150",
    "\1\u0151",
    "\1\u0152",
    "\1\u0153",
    "\1\u0154",
    "",
    "",
    "\1\u0155",
    "\1\u0156",
    "\1\u0157",
    "\1\u0158",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u015a",
    "\1\u015b",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u015d",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u015f",
    "",
    "",
    "\1\u0160",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0162",
    "\1\u0163",
    "\1\u0164",
    "\1\u0165",
    "\1\u0166",
    "\1\u0167",
    "\1\u0168\3\uffff\1\u0169\10\uffff\1\u016a\3\uffff\1\u016b",
    "\1\u016c",
    "\1\u016d",
    "\1\u016e",
    "\1\u016f",
    "\1\u0170",
    "\1\u0171",
    "\1\u0172",
    "\1\u0173",
    "\1\u0174",
    "\1\u0175",
    "\1\u0176\5\uffff\1\u0177",
    "\1\u0178",
    "\1\u0179",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u017d",
    "\1\u017e",
    "\1\u017f",
    "\1\u0180",
    "\1\u0181",
    "\1\u0182",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0184",
    "\1\u0185",
    "\1\u0186",
    "\1\u0187",
    "\1\u0188",
    "\1\u0189",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\1\u018a\7\64\1\u018b\21\64" + "\5\uffff\uff7f\64",
    "\1\u018d",
    "\1\u018e",
    "\1\u018f",
    "\1\u0190",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0192",
    "\1\u0193",
    "\1\u0194",
    "\1\u0195",
    "\1\u0196",
    "\1\u0197",
    "\1\u0198",
    "\1\u0199",
    "\1\u019a",
    "\1\u019b",
    "\1\u019c",
    "\1\u019d",
    "\1\u019e",
    "\12\u019f\1\110\6\uffff\6\u00aa\1\uffff\1\u00ab\30\uffff\6\u00aa\1\uffff" + "\1\u00ab",
    "\1\u01a0",
    "\1\u01a1",
    "",
    "",
    "\1\u01a2",
    "\1\u01a3",
    "",
    "\1\u01a4",
    "\1\u01a5",
    "\1\u01a6",
    "\1\u01a7",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\6\103\1\uffff\1\106" + "\3\uffff\1\u01a9",
    "\1\u01aa",
    "\1\u01ab",
    "\1\u01ac\7\uffff\1\u01ad",
    "\12\105\1\110\6\uffff\6\104\1\uffff\1\107\30\uffff\6\103\1\uffff\1\106" + "\14\uffff\1\u01ae",
    "\1\u01af",
    "\1\u01b0",
    "\1\u01b1",
    "",
    "\1\u01b2",
    "\1\u01b3",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u01b5",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u01b7",
    "\1\u01b8",
    "\1\u01b9",
    "",
    "\1\u01ba",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u01bc",
    "\1\u01bd",
    "",
    "\1\u01be",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u01c0",
    "\1\u01c1",
    "\1\u01c2",
    "\1\u01c3",
    "\1\u01c4",
    "\1\u01c5",
    "\1\u01c6",
    "\1\u01c7",
    "\1\u01c8",
    "\1\u01c9",
    "\1\u01ca",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u01cd",
    "",
    "\1\u01ce",
    "\1\u01cf",
    "",
    "\1\u01d0\5\uffff\1\u01d1",
    "\1\u01d2\3\uffff\1\u01d3",
    "\1\u01d4",
    "\1\u01d5",
    "\1\u01d6",
    "\1\u01d7",
    "\1\u01d8",
    "\1\u01d9",
    "\1\u01da",
    "\1\u01db",
    "\1\u01dc",
    "\1\u01dd",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\16\64\1\u01de\13\64\5\uffff" + "\uff7f\64",
    "\1\u01e0",
    "\1\u01e1",
    "\1\u01e2",
    "\1\u01e3",
    "\1\u01e4",
    "\1\u01e5",
    "\1\u01e6",
    "\1\u01e7",
    "\1\u01e8",
    "\1\u01e9",
    "\1\u01ea",
    "",
    "",
    "",
    "\1\u01eb",
    "\1\u01ec",
    "\1\u01ed",
    "\1\u01ee\12\uffff\1\u01ef",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u01f1",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u01f5",
    "\1\u01f6",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u01f8",
    "\1\u01f9",
    "",
    "\1\u01fa",
    "\1\u01fb",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u01fd",
    "",
    "\1\u01fe",
    "\1\u01ff",
    "\1\u0200",
    "\1\u0201",
    "\1\u0202",
    "\1\u0203",
    "\1\u0204",
    "\1\u0205",
    "\1\u0206",
    "\1\u0207",
    "\1\u0208",
    "\1\u0209",
    "\1\u020a",
    "\12\u019f\1\110\6\uffff\6\u00aa\1\uffff\1\u00ab\30\uffff\6\u00aa\1\uffff" + "\1\u00ab",
    "\1\u020b",
    "\1\u020c",
    "\1\u020d",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u020f",
    "\1\u0210",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\21\64\1\u0215\10\64\5\uffff" + "\uff7f\64",
    "\1\u0217",
    "\1\u0218",
    "\1\u0219",
    "\1\u021a",
    "\1\u021b",
    "\1\u021c\11\uffff\1\u021d",
    "\1\u021e",
    "\1\u021f",
    "",
    "\1\u0220",
    "",
    "\1\u0221",
    "\1\u0222",
    "\1\u0223",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\10\64\1\u0225\2\64\1\u0226"
        + "\16\64\5\uffff\uff7f\64",
    "\1\u0228",
    "\1\u0229",
    "",
    "\1\u022a",
    "\1\u022b",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u022d",
    "\1\u022e",
    "\1\u022f",
    "\1\u0230",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0232",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0234",
    "",
    "",
    "\1\u0235",
    "\1\u0236",
    "\1\u0237",
    "\1\u0238",
    "\1\u0239",
    "\1\u023a",
    "\1\u023b",
    "\1\u023c",
    "\1\u023d",
    "\1\u023e",
    "\1\u023f",
    "\1\u0240",
    "\1\u0241",
    "\1\u0242",
    "\1\u0243",
    "\1\u0244\17\uffff\1\u0245",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0247",
    "",
    "\1\u0248",
    "\1\u0249",
    "\1\u024a",
    "\1\u024b",
    "\1\u024c",
    "\1\u024d",
    "\1\u024e",
    "\1\u024f",
    "\1\u0250",
    "\1\u0251",
    "\1\u0252",
    "\1\u0253",
    "\1\u0254",
    "\1\u0255",
    "\1\u0256",
    "\1\u0257",
    "",
    "\1\u0258",
    "",
    "",
    "",
    "\1\u0259",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u025b",
    "\1\u025c",
    "\1\u025d",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\16\64\1\u025f\13\64\5\uffff" + "\uff7f\64",
    "\1\u0261",
    "\1\u0262",
    "\1\u0263",
    "\12\64\7\uffff\32\64\4\uffff\1\u0264\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0266",
    "\1\u0267",
    "\1\u0268",
    "\1\u0269",
    "\1\u026a",
    "\1\u026b",
    "\1\u026c",
    "\1\u026d",
    "\1\u026e",
    "\1\u026f",
    "\1\u0270",
    "\1\u0271",
    "",
    "\1\u0272",
    "\1\u0273",
    "",
    "",
    "",
    "",
    "\1\u0274",
    "",
    "\1\u0275",
    "\1\u0276",
    "\1\u0277",
    "\1\u0278",
    "\1\u0279",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u027b",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u027d",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u027f",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\22\64\1\u0280\7\64\5\uffff" + "\uff7f\64",
    "\1\u0282",
    "",
    "\1\u0283",
    "\1\u0284",
    "",
    "\1\u0285",
    "\1\u0286",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0288",
    "",
    "\1\u0289",
    "\1\u028a",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u028c",
    "",
    "\1\u028d",
    "",
    "\1\u028e",
    "\1\u028f",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0291",
    "\1\u0292",
    "\1\u0293",
    "\1\u0294",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0297",
    "\1\u0298",
    "\1\u0299",
    "\1\u029a",
    "\1\u029b",
    "\1\u029c",
    "\1\u029d",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u029f",
    "",
    "\1\u02a0",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u02a2",
    "\1\u02a3",
    "\1\u02a4",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u02a7",
    "\1\u02a8",
    "\1\u02a9",
    "\1\u02aa",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u02ad",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u02b1",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u02b3",
    "\1\u02b4",
    "\1\u02b5",
    "",
    "\1\u02b6",
    "",
    "\1\u02b7",
    "\1\u02b8",
    "\1\u02b9",
    "\1\u02bc\10\uffff\1\u02ba\1\u02bb",
    "",
    "\1\u02bd",
    "\1\u02be",
    "\1\u02bf",
    "\1\u02c0",
    "\1\u02c1",
    "\1\u02c2",
    "\1\u02c3",
    "\1\u02c4",
    "\1\u02c5",
    "\1\u02c6",
    "\1\u02c7",
    "\1\u02c8",
    "\1\u02c9\23\uffff\1\u02ca",
    "\1\u02cb",
    "\1\u02cc",
    "\1\u02cd",
    "\1\u02ce",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u02d0",
    "\1\u02d1",
    "",
    "\1\u02d2",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u02d4",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u02d6",
    "\1\u02d7",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u02da",
    "",
    "\1\u02db",
    "\1\u02dc",
    "\1\u02dd",
    "",
    "\1\u02de",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u02e1",
    "",
    "\1\u02e2",
    "\1\u02e3",
    "\1\u02e4",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "",
    "\1\u02e6",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u02e9",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u02eb",
    "\1\u02ec",
    "",
    "\1\u02ed",
    "\1\u02ee",
    "",
    "\1\u02ef",
    "\1\u02f0",
    "\1\u02f1",
    "",
    "",
    "\1\u02f2",
    "\1\u02f3",
    "\1\u02f4",
    "\1\u02f5",
    "",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "",
    "",
    "\1\u02f7",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u02fb",
    "\1\u02fc",
    "\1\u02fd",
    "\1\u02fe",
    "\1\u02ff",
    "\1\u0300",
    "\1\u0301",
    "\1\u0302",
    "\1\u0304\13\uffff\1\u0303",
    "\1\u0305",
    "\1\u0306",
    "\1\u0307",
    "\1\u0308",
    "\1\u0309",
    "\1\u030a",
    "\1\u030b",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u030e",
    "\1\u030f",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0311",
    "\1\u0312",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u0315",
    "\1\u0316",
    "\1\u0317",
    "",
    "\1\u0318",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u031a",
    "",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u031c",
    "\1\u031d",
    "\1\u031e",
    "\1\u031f",
    "",
    "",
    "\1\u0320",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "",
    "\1\u0325",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0327",
    "\1\u0328",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u032a",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u032c",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u032f",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u0331",
    "",
    "",
    "",
    "\1\u0332",
    "\1\u0333",
    "\1\u0334",
    "\1\u0335",
    "\1\u0336",
    "\1\u0337",
    "\1\u0338",
    "\12\64\7\uffff\32\64\4\uffff\1\u0339\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u033b",
    "\1\u033c",
    "\1\u033d",
    "\1\u033e",
    "\1\u033f",
    "\1\u0340",
    "\1\u0341",
    "\1\u0342",
    "\1\u0343",
    "",
    "",
    "\1\u0344",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0347",
    "",
    "",
    "\1\u0348",
    "\1\u0349",
    "\1\u034a",
    "\1\u034b",
    "",
    "\1\u034c",
    "",
    "\1\u034d\21\uffff\1\u034e",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0350",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "",
    "",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u0357",
    "",
    "",
    "\1\u0358",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u035d\1\u035e\4\uffff\1\u035b\6\uffff\1\u035c\3\uffff\1\u035f",
    "\1\u0360",
    "\1\u0361",
    "\1\u0362",
    "\1\u0363",
    "\1\u0364",
    "\1\u0366\11\uffff\1\u0365",
    "",
    "\1\u0367",
    "\1\u0368",
    "\1\u0369",
    "\1\u036a",
    "\1\u036c\6\uffff\1\u036d\3\uffff\1\u036b",
    "\1\u036e",
    "\1\u036f",
    "\1\u0370",
    "\1\u0371",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "",
    "\1\u0373",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0376",
    "\1\u0377",
    "\1\u0378",
    "\1\u0379",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u037b",
    "",
    "",
    "",
    "",
    "",
    "",
    "\1\u037c",
    "\1\u037d",
    "",
    "",
    "\1\u037e",
    "\1\u037f",
    "\1\u0380",
    "\1\u0381",
    "\1\u0382",
    "\1\u0383",
    "\1\u0384",
    "\1\u0385",
    "\1\u0386",
    "\1\u0387",
    "\1\u0388",
    "\1\u0389",
    "\1\u038a",
    "\1\u038b",
    "\1\u038d\14\uffff\1\u038c",
    "\1\u038e",
    "\1\u038f",
    "\1\u0390",
    "\1\u0391",
    "\1\u0392",
    "\1\u0393",
    "\1\u0394",
    "\1\u0395",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "",
    "\1\u0397",
    "\1\u0398",
    "\1\u0399",
    "\1\u039a",
    "",
    "\1\u039b",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u039d",
    "\1\u039e",
    "\1\u039f",
    "\1\u03a0",
    "\1\u03a1",
    "\1\u03a2",
    "\1\u03a3",
    "\1\u03a4",
    "\1\u03a5",
    "\1\u03a6",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u03a8",
    "\1\u03a9",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u03ab",
    "\1\u03ac",
    "\1\u03ad",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u03af",
    "\1\u03b0",
    "\1\u03b1",
    "\1\u03b2",
    "\1\u03b3",
    "\1\u03b4",
    "\1\u03b5",
    "",
    "\1\u03b6",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u03b9",
    "\1\u03ba",
    "",
    "\1\u03bb",
    "\1\u03bc",
    "\1\u03bd",
    "\1\u03be",
    "\1\u03bf",
    "\1\u03c0",
    "\1\u03c1",
    "\1\u03c2",
    "\1\u03c3",
    "\1\u03c4",
    "",
    "\1\u03c5",
    "\1\u03c6",
    "",
    "\1\u03c7",
    "\1\u03c8",
    "\1\u03c9",
    "",
    "\1\u03ca",
    "\1\u03cb",
    "\1\u03cc",
    "\1\u03cd",
    "\1\u03ce",
    "\1\u03cf",
    "\1\u03d0",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "",
    "\1\u03d2",
    "\1\u03d3",
    "\1\u03d4",
    "\1\u03d5",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u03d9",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u03db",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u03e1",
    "\1\u03e2",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u03e4",
    "\1\u03e5",
    "\1\u03e6",
    "\1\u03e7",
    "\1\u03e8",
    "\1\u03e9",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u03ed",
    "",
    "",
    "",
    "\1\u03ee",
    "",
    "\1\u03ef",
    "",
    "",
    "",
    "",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u03f2",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u03f4",
    "\1\u03f5",
    "\1\u03f6",
    "\1\u03f7",
    "",
    "",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u03fa",
    "",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u03fc",
    "\1\u03fd",
    "\1\u03fe",
    "\1\u03ff",
    "",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\u0400\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u0402",
    "\1\u0403",
    "\1\u0404",
    "\1\u0405",
    "\1\u0406",
    "",
    "\1\u0407",
    "\1\u0408",
    "\1\u0409",
    "\12\64\7\uffff\32\64\4\uffff\1\u040a\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u040c",
    "\1\u040d",
    "\1\u040e",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0410",
    "",
    "\1\u0411",
    "\1\u0412",
    "\1\u0413",
    "",
    "\1\u0414",
    "\1\u0415",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u0417",
    "\1\u0418",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "",
    "\1\u041a",
    "\1\u041b",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    "\1\u041d",
    "",
    "\12\64\7\uffff\32\64\4\uffff\1\64\1\uffff\32\64\5\uffff\uff7f\64",
    ""
  };

  static final short[] DFA18_eot = DFA.unpackEncodedString(DFA18_eotS);
  static final short[] DFA18_eof = DFA.unpackEncodedString(DFA18_eofS);
  static final char[] DFA18_min = DFA.unpackEncodedStringToUnsignedChars(DFA18_minS);
  static final char[] DFA18_max = DFA.unpackEncodedStringToUnsignedChars(DFA18_maxS);
  static final short[] DFA18_accept = DFA.unpackEncodedString(DFA18_acceptS);
  static final short[] DFA18_special = DFA.unpackEncodedString(DFA18_specialS);
  static final short[][] DFA18_transition;

  static {
    int numStates = DFA18_transitionS.length;
    DFA18_transition = new short[numStates][];
    for (int i = 0; i < numStates; i++) {
      DFA18_transition[i] = DFA.unpackEncodedString(DFA18_transitionS[i]);
    }
  }

  protected class DFA18 extends DFA {

    public DFA18(BaseRecognizer recognizer) {
      this.recognizer = recognizer;
      this.decisionNumber = 18;
      this.eot = DFA18_eot;
      this.eof = DFA18_eof;
      this.min = DFA18_min;
      this.max = DFA18_max;
      this.accept = DFA18_accept;
      this.special = DFA18_special;
      this.transition = DFA18_transition;
    }

    @Override
    public String getDescription() {
      return "1:1: Tokens : ( ABSOLUTE | ABSTRACT | ADD | AND | ANSISTRING | ARRAY | AS | ASM | ASSEMBLER | ASSEMBLY | AT | AUTOMATED | BEGIN | BREAK | CASE | CDECL | CLASS | CONST | CONSTRUCTOR | CONTAINS | CONTINUE | DEFAULT | DEPRECATED | DESTRUCTOR | DISPID | DISPINTERFACE | DIV | DO | DOWNTO | DQ | DW | DYNAMIC | ELSE | END | EXCEPT | EXIT | EXPERIMENTAL | EXPORT | EXPORTS | EXTERNAL | FAR | FILE | FINAL | FINALIZATION | FINALLY | FOR | FORWARD | FUNCTION | GOTO | HELPER | IF | IMPLEMENTATION | IMPLEMENTS | IN | INDEX | INHERITED | INITIALIZATION | INLINE | INTERFACE | IS | LABEL | LIBRARY | LOCAL | MESSAGE | MOD | NAME | NEAR | NIL | NODEFAULT | NOT | OBJECT | OF | ON | OPERATOR | OR | OUT | OVERLOAD | OVERRIDE | PACKAGE | PACKED | PASCAL | PLATFORM | POINTER | PRIVATE | PROCEDURE | PROGRAM | PROPERTY | PROTECTED | PUBLIC | PUBLISHED | RAISE | READ | READONLY | RECORD | REFERENCE | REGISTER | REINTRODUCE | REMOVE | REPEAT | REQUIRES | RESIDENT | RESOURCESTRING | SAFECALL | SEALED | SET | SHL | SHR | STATIC | STDCALL | STORED | STRICT | STRING | THEN | THREADVAR | TO | TRY | TYPE | UNIT | UNSAFE | UNTIL | USES | VAR | VARARGS | VARIANT | VIRTUAL | WHILE | WITH | WRITE | WRITEONLY | XOR | FALSE | TRUE | PLUS | MINUS | STAR | SLASH | ASSIGN | COMMA | SEMI | COLON | EQUAL | NOT_EQUAL | LT | LE | GE | GT | LPAREN | RPAREN | LBRACK | LBRACK2 | RBRACK | RBRACK2 | POINTER2 | AT2 | DOT | DOTDOT | LCURLY | RCURLY | AMPERSAND | TkGlobalFunction | TkFunctionName | TkConstantName | TkFunctionArgs | TkFunctionBody | TkFunctionReturn | TkCustomAttribute | TkCustomAttributeArgs | TkNewType | TkNewTypeName | TkNewTypeDecl | TkClass | TkRecord | TkRecordHelper | TkInterface | TkObject | TkClassOfType | TkVariableType | TkVariableIdents | TkVariableParam | TkGuid | TkClassParents | TkClassField | TkAnonymousExpression | TkAssemblerInstructions | TkBlockDeclSection | TkExceptionHandlerIdent | TkExceptionHandler | TkIdentifier | TkIntNum | TkRealNum | TkHexNum | TkAsmHexNum | TkAsmHexLabel | QuotedString | ControlString | COMMENT | WS | UnicodeBOM );";
    }

    @Override
    public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
      IntStream input = _input;
      int _s = s;
      switch (s) {
        case 0:
          int LA18_170 = input.LA(1);

          int index18_170 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_170 == 'H' || LA18_170 == 'h') && ((asmMode))) {
            s = 171;
          } else if (((LA18_170 >= '0' && LA18_170 <= '9')
                  || (LA18_170 >= 'A' && LA18_170 <= 'F')
                  || (LA18_170 >= 'a' && LA18_170 <= 'f'))
              && ((asmMode))) {
            s = 170;
          } else if ((LA18_170 == ':') && ((asmMode))) {
            s = 72;
          }

          input.seek(index18_170);
          if (s >= 0) return s;
          break;

        case 1:
          int LA18_39 = input.LA(1);
          s = -1;
          if (((LA18_39 >= '\u0000' && LA18_39 <= '\uFFFF'))) {
            s = 137;
          } else s = 151;
          if (s >= 0) return s;
          break;

        case 2:
          int LA18_51 = input.LA(1);

          int index18_51 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_51 == 'X')) {
            s = 164;
          } else if (((LA18_51 >= 'a' && LA18_51 <= 'f'))) {
            s = 67;
          } else if (((LA18_51 >= 'A' && LA18_51 <= 'F'))) {
            s = 68;
          } else if (((LA18_51 >= '0' && LA18_51 <= '9'))) {
            s = 69;
          } else if ((LA18_51 == 'h')) {
            s = 70;
          } else if ((LA18_51 == 'H')) {
            s = 71;
          } else if ((LA18_51 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_51);
          if (s >= 0) return s;
          break;

        case 3:
          int LA18_173 = input.LA(1);

          int index18_173 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_173 == 'h')) {
            s = 70;
          } else if ((LA18_173 == 'H')) {
            s = 71;
          } else if ((LA18_173 == 'G'
              || (LA18_173 >= 'I' && LA18_173 <= 'Z')
              || LA18_173 == '_'
              || LA18_173 == 'g'
              || (LA18_173 >= 'i' && LA18_173 <= 'z')
              || (LA18_173 >= '\u0080' && LA18_173 <= '\uFFFE'))) {
            s = 52;
          } else if (((LA18_173 >= '0' && LA18_173 <= '9'))) {
            s = 69;
          } else if (((LA18_173 >= 'a' && LA18_173 <= 'f'))) {
            s = 67;
          } else if (((LA18_173 >= 'A' && LA18_173 <= 'F'))) {
            s = 68;
          } else if ((LA18_173 == ':') && ((asmMode))) {
            s = 72;
          } else s = 298;

          input.seek(index18_173);
          if (s >= 0) return s;
          break;

        case 4:
          int LA18_295 = input.LA(1);

          int index18_295 = input.index();
          input.rewind();
          s = -1;
          if (((LA18_295 >= '0' && LA18_295 <= '9'))) {
            s = 415;
          } else if ((LA18_295 == 'H' || LA18_295 == 'h') && ((asmMode))) {
            s = 171;
          } else if (((LA18_295 >= 'A' && LA18_295 <= 'F') || (LA18_295 >= 'a' && LA18_295 <= 'f'))
              && ((asmMode))) {
            s = 170;
          } else if ((LA18_295 == ':') && ((asmMode))) {
            s = 72;
          } else s = 168;

          input.seek(index18_295);
          if (s >= 0) return s;
          break;

        case 5:
          int LA18_182 = input.LA(1);

          int index18_182 = input.index();
          input.rewind();
          s = -1;
          if ((!(((asmMode))))) {
            s = 52;
          } else if (((asmMode))) {
            s = 171;
          }

          input.seek(index18_182);
          if (s >= 0) return s;
          break;

        case 6:
          int LA18_183 = input.LA(1);

          int index18_183 = input.index();
          input.rewind();
          s = -1;
          if ((!(((asmMode))))) {
            s = 52;
          } else if (((asmMode))) {
            s = 171;
          }

          input.seek(index18_183);
          if (s >= 0) return s;
          break;

        case 7:
          int LA18_69 = input.LA(1);

          int index18_69 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_69 == 'h')) {
            s = 70;
          } else if ((LA18_69 == 'H')) {
            s = 71;
          } else if (((LA18_69 >= '0' && LA18_69 <= '9'))) {
            s = 69;
          } else if (((LA18_69 >= 'a' && LA18_69 <= 'f'))) {
            s = 67;
          } else if (((LA18_69 >= 'A' && LA18_69 <= 'F'))) {
            s = 68;
          } else if ((LA18_69 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_69);
          if (s >= 0) return s;
          break;

        case 8:
          int LA18_79 = input.LA(1);

          int index18_79 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_79 == 'f')) {
            s = 190;
          } else if ((LA18_79 == 'p')) {
            s = 191;
          } else if ((LA18_79 == 's')) {
            s = 192;
          } else if ((LA18_79 == 'h')) {
            s = 70;
          } else if ((LA18_79 == 'H')) {
            s = 71;
          } else if (((LA18_79 >= '0' && LA18_79 <= '9'))) {
            s = 69;
          } else if (((LA18_79 >= 'a' && LA18_79 <= 'e'))) {
            s = 67;
          } else if (((LA18_79 >= 'A' && LA18_79 <= 'F'))) {
            s = 68;
          } else if ((LA18_79 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_79);
          if (s >= 0) return s;
          break;

        case 9:
          int LA18_42 = input.LA(1);

          int index18_42 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_42 == 'U')) {
            s = 152;
          } else if (((LA18_42 >= 'a' && LA18_42 <= 'f'))) {
            s = 67;
          } else if (((LA18_42 >= 'A' && LA18_42 <= 'F'))) {
            s = 68;
          } else if (((LA18_42 >= '0' && LA18_42 <= '9'))) {
            s = 69;
          } else if ((LA18_42 == 'h')) {
            s = 70;
          } else if ((LA18_42 == 'H')) {
            s = 71;
          } else if ((LA18_42 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_42);
          if (s >= 0) return s;
          break;

        case 10:
          int LA18_67 = input.LA(1);

          int index18_67 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_67 == 'h')) {
            s = 70;
          } else if ((LA18_67 == 'H')) {
            s = 71;
          } else if (((LA18_67 >= '0' && LA18_67 <= '9'))) {
            s = 69;
          } else if (((LA18_67 >= 'a' && LA18_67 <= 'f'))) {
            s = 67;
          } else if (((LA18_67 >= 'A' && LA18_67 <= 'F'))) {
            s = 68;
          } else if ((LA18_67 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_67);
          if (s >= 0) return s;
          break;

        case 11:
          int LA18_68 = input.LA(1);

          int index18_68 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_68 == 'h')) {
            s = 70;
          } else if ((LA18_68 == 'H')) {
            s = 71;
          } else if (((LA18_68 >= '0' && LA18_68 <= '9'))) {
            s = 69;
          } else if (((LA18_68 >= 'a' && LA18_68 <= 'f'))) {
            s = 67;
          } else if (((LA18_68 >= 'A' && LA18_68 <= 'F'))) {
            s = 68;
          } else if ((LA18_68 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_68);
          if (s >= 0) return s;
          break;

        case 12:
          int LA18_55 = input.LA(1);

          int index18_55 = input.index();
          input.rewind();
          s = -1;
          if (((LA18_55 >= '0' && LA18_55 <= '9'))) {
            s = 167;
          } else if ((LA18_55 == '.')) {
            s = 168;
          } else if ((LA18_55 == 'E' || LA18_55 == 'e')) {
            s = 169;
          } else if (((LA18_55 >= 'A' && LA18_55 <= 'D')
                  || LA18_55 == 'F'
                  || (LA18_55 >= 'a' && LA18_55 <= 'd')
                  || LA18_55 == 'f')
              && ((asmMode))) {
            s = 170;
          } else if ((LA18_55 == 'H' || LA18_55 == 'h') && ((asmMode))) {
            s = 171;
          } else if ((LA18_55 == ':') && ((asmMode))) {
            s = 72;
          } else s = 166;

          input.seek(index18_55);
          if (s >= 0) return s;
          break;

        case 13:
          int LA18_415 = input.LA(1);

          int index18_415 = input.index();
          input.rewind();
          s = -1;
          if (((LA18_415 >= '0' && LA18_415 <= '9'))) {
            s = 415;
          } else if ((LA18_415 == 'H' || LA18_415 == 'h') && ((asmMode))) {
            s = 171;
          } else if (((LA18_415 >= 'A' && LA18_415 <= 'F') || (LA18_415 >= 'a' && LA18_415 <= 'f'))
              && ((asmMode))) {
            s = 170;
          } else if ((LA18_415 == ':') && ((asmMode))) {
            s = 72;
          } else s = 168;

          input.seek(index18_415);
          if (s >= 0) return s;
          break;

        case 14:
          int LA18_167 = input.LA(1);

          int index18_167 = input.index();
          input.rewind();
          s = -1;
          if (((LA18_167 >= '0' && LA18_167 <= '9'))) {
            s = 167;
          } else if ((LA18_167 == '.')) {
            s = 168;
          } else if ((LA18_167 == 'E' || LA18_167 == 'e')) {
            s = 169;
          } else if ((LA18_167 == 'H' || LA18_167 == 'h') && ((asmMode))) {
            s = 171;
          } else if (((LA18_167 >= 'A' && LA18_167 <= 'D')
                  || LA18_167 == 'F'
                  || (LA18_167 >= 'a' && LA18_167 <= 'd')
                  || LA18_167 == 'f')
              && ((asmMode))) {
            s = 170;
          } else if ((LA18_167 == ':') && ((asmMode))) {
            s = 72;
          } else s = 166;

          input.seek(index18_167);
          if (s >= 0) return s;
          break;

        case 15:
          int LA18_2 = input.LA(1);

          int index18_2 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_2 == 'e')) {
            s = 73;
          } else if ((LA18_2 == 'r')) {
            s = 74;
          } else if (((LA18_2 >= 'a' && LA18_2 <= 'd') || LA18_2 == 'f')) {
            s = 67;
          } else if (((LA18_2 >= 'A' && LA18_2 <= 'F'))) {
            s = 68;
          } else if (((LA18_2 >= '0' && LA18_2 <= '9'))) {
            s = 69;
          } else if ((LA18_2 == 'h')) {
            s = 70;
          } else if ((LA18_2 == 'H')) {
            s = 71;
          } else if ((LA18_2 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_2);
          if (s >= 0) return s;
          break;

        case 16:
          int LA18_4 = input.LA(1);

          int index18_4 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_4 == 'e')) {
            s = 79;
          } else if ((LA18_4 == 'i')) {
            s = 80;
          } else if ((LA18_4 == 'o')) {
            s = 81;
          } else if ((LA18_4 == 'q')) {
            s = 82;
          } else if ((LA18_4 == 'w')) {
            s = 83;
          } else if ((LA18_4 == 'y')) {
            s = 84;
          } else if (((LA18_4 >= 'a' && LA18_4 <= 'd') || LA18_4 == 'f')) {
            s = 67;
          } else if (((LA18_4 >= 'A' && LA18_4 <= 'F'))) {
            s = 68;
          } else if (((LA18_4 >= '0' && LA18_4 <= '9'))) {
            s = 69;
          } else if ((LA18_4 == 'h')) {
            s = 70;
          } else if ((LA18_4 == 'H')) {
            s = 71;
          } else if ((LA18_4 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_4);
          if (s >= 0) return s;
          break;

        case 17:
          int LA18_88 = input.LA(1);

          int index18_88 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_88 == 'r')) {
            s = 206;
          } else if ((LA18_88 == 'l')) {
            s = 207;
          } else if ((LA18_88 == 'h')) {
            s = 70;
          } else if ((LA18_88 == 'H')) {
            s = 71;
          } else if (((LA18_88 >= '0' && LA18_88 <= '9'))) {
            s = 69;
          } else if (((LA18_88 >= 'a' && LA18_88 <= 'f'))) {
            s = 67;
          } else if (((LA18_88 >= 'A' && LA18_88 <= 'F'))) {
            s = 68;
          } else if ((LA18_88 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_88);
          if (s >= 0) return s;
          break;

        case 18:
          int LA18_61 = input.LA(1);

          int index18_61 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_61 == 'd')) {
            s = 173;
          } else if ((LA18_61 == 'h')) {
            s = 70;
          } else if ((LA18_61 == 'H')) {
            s = 71;
          } else if (((LA18_61 >= '0' && LA18_61 <= '9'))) {
            s = 69;
          } else if (((LA18_61 >= 'a' && LA18_61 <= 'c') || (LA18_61 >= 'e' && LA18_61 <= 'f'))) {
            s = 67;
          } else if (((LA18_61 >= 'A' && LA18_61 <= 'F'))) {
            s = 68;
          } else if ((LA18_61 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_61);
          if (s >= 0) return s;
          break;

        case 19:
          int LA18_43 = input.LA(1);

          int index18_43 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_43 == 'O')) {
            s = 153;
          } else if ((LA18_43 == 'U')) {
            s = 154;
          } else if ((LA18_43 == 'L')) {
            s = 155;
          } else if (((LA18_43 >= 'a' && LA18_43 <= 'f'))) {
            s = 67;
          } else if (((LA18_43 >= 'A' && LA18_43 <= 'F'))) {
            s = 68;
          } else if (((LA18_43 >= '0' && LA18_43 <= '9'))) {
            s = 69;
          } else if ((LA18_43 == 'h')) {
            s = 70;
          } else if ((LA18_43 == 'H')) {
            s = 71;
          } else if ((LA18_43 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_43);
          if (s >= 0) return s;
          break;

        case 20:
          int LA18_73 = input.LA(1);

          int index18_73 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_73 == 'g')) {
            s = 184;
          } else if ((LA18_73 == 'h')) {
            s = 70;
          } else if ((LA18_73 == 'H')) {
            s = 71;
          } else if (((LA18_73 >= '0' && LA18_73 <= '9'))) {
            s = 69;
          } else if (((LA18_73 >= 'a' && LA18_73 <= 'f'))) {
            s = 67;
          } else if (((LA18_73 >= 'A' && LA18_73 <= 'F'))) {
            s = 68;
          } else if ((LA18_73 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_73);
          if (s >= 0) return s;
          break;

        case 21:
          int LA18_75 = input.LA(1);

          int index18_75 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_75 == 's')) {
            s = 186;
          } else if ((LA18_75 == 'h')) {
            s = 70;
          } else if ((LA18_75 == 'H')) {
            s = 71;
          } else if (((LA18_75 >= '0' && LA18_75 <= '9'))) {
            s = 69;
          } else if (((LA18_75 >= 'a' && LA18_75 <= 'f'))) {
            s = 67;
          } else if (((LA18_75 >= 'A' && LA18_75 <= 'F'))) {
            s = 68;
          } else if ((LA18_75 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_75);
          if (s >= 0) return s;
          break;

        case 22:
          int LA18_76 = input.LA(1);

          int index18_76 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_76 == 'e')) {
            s = 187;
          } else if ((LA18_76 == 'h')) {
            s = 70;
          } else if ((LA18_76 == 'H')) {
            s = 71;
          } else if (((LA18_76 >= '0' && LA18_76 <= '9'))) {
            s = 69;
          } else if (((LA18_76 >= 'a' && LA18_76 <= 'd') || LA18_76 == 'f')) {
            s = 67;
          } else if (((LA18_76 >= 'A' && LA18_76 <= 'F'))) {
            s = 68;
          } else if ((LA18_76 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_76);
          if (s >= 0) return s;
          break;

        case 23:
          int LA18_308 = input.LA(1);

          int index18_308 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_308 == 'l')) {
            s = 425;
          } else if ((LA18_308 == 'h')) {
            s = 70;
          } else if ((LA18_308 == 'H')) {
            s = 71;
          } else if (((LA18_308 >= '0' && LA18_308 <= '9'))) {
            s = 69;
          } else if (((LA18_308 >= 'a' && LA18_308 <= 'f'))) {
            s = 67;
          } else if (((LA18_308 >= 'A' && LA18_308 <= 'F'))) {
            s = 68;
          } else if ((LA18_308 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_308);
          if (s >= 0) return s;
          break;

        case 24:
          int LA18_187 = input.LA(1);

          int index18_187 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_187 == 'c')) {
            s = 308;
          } else if ((LA18_187 == 'h')) {
            s = 70;
          } else if ((LA18_187 == 'H')) {
            s = 71;
          } else if (((LA18_187 >= '0' && LA18_187 <= '9'))) {
            s = 69;
          } else if (((LA18_187 >= 'a' && LA18_187 <= 'b')
              || (LA18_187 >= 'd' && LA18_187 <= 'f'))) {
            s = 67;
          } else if (((LA18_187 >= 'A' && LA18_187 <= 'F'))) {
            s = 68;
          } else if ((LA18_187 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_187);
          if (s >= 0) return s;
          break;

        case 25:
          int LA18_312 = input.LA(1);

          int index18_312 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_312 == 'u')) {
            s = 430;
          } else if ((LA18_312 == 'h')) {
            s = 70;
          } else if ((LA18_312 == 'H')) {
            s = 71;
          } else if (((LA18_312 >= '0' && LA18_312 <= '9'))) {
            s = 69;
          } else if (((LA18_312 >= 'a' && LA18_312 <= 'f'))) {
            s = 67;
          } else if (((LA18_312 >= 'A' && LA18_312 <= 'F'))) {
            s = 68;
          } else if ((LA18_312 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_312);
          if (s >= 0) return s;
          break;

        case 26:
          int LA18_190 = input.LA(1);

          int index18_190 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_190 == 'a')) {
            s = 312;
          } else if ((LA18_190 == 'h')) {
            s = 70;
          } else if ((LA18_190 == 'H')) {
            s = 71;
          } else if (((LA18_190 >= '0' && LA18_190 <= '9'))) {
            s = 69;
          } else if (((LA18_190 >= 'b' && LA18_190 <= 'f'))) {
            s = 67;
          } else if (((LA18_190 >= 'A' && LA18_190 <= 'F'))) {
            s = 68;
          } else if ((LA18_190 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_190);
          if (s >= 0) return s;
          break;

        case 27:
          int LA18_1 = input.LA(1);

          int index18_1 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_1 == 'b')) {
            s = 60;
          } else if ((LA18_1 == 'd')) {
            s = 61;
          } else if ((LA18_1 == 'n')) {
            s = 62;
          } else if ((LA18_1 == 'r')) {
            s = 63;
          } else if ((LA18_1 == 's')) {
            s = 64;
          } else if ((LA18_1 == 't')) {
            s = 65;
          } else if ((LA18_1 == 'u')) {
            s = 66;
          } else if ((LA18_1 == 'a' || LA18_1 == 'c' || (LA18_1 >= 'e' && LA18_1 <= 'f'))) {
            s = 67;
          } else if (((LA18_1 >= 'A' && LA18_1 <= 'F'))) {
            s = 68;
          } else if (((LA18_1 >= '0' && LA18_1 <= '9'))) {
            s = 69;
          } else if ((LA18_1 == 'h')) {
            s = 70;
          } else if ((LA18_1 == 'H')) {
            s = 71;
          } else if ((LA18_1 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_1);
          if (s >= 0) return s;
          break;

        case 28:
          int LA18_169 = input.LA(1);

          int index18_169 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_169 == '+' || LA18_169 == '-')) {
            s = 168;
          } else if (((LA18_169 >= '0' && LA18_169 <= '9'))) {
            s = 295;
          } else if ((LA18_169 == 'H' || LA18_169 == 'h') && ((asmMode))) {
            s = 171;
          } else if (((LA18_169 >= 'A' && LA18_169 <= 'F') || (LA18_169 >= 'a' && LA18_169 <= 'f'))
              && ((asmMode))) {
            s = 170;
          } else if ((LA18_169 == ':') && ((asmMode))) {
            s = 72;
          }

          input.seek(index18_169);
          if (s >= 0) return s;
          break;

        case 29:
          int LA18_60 = input.LA(1);

          int index18_60 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_60 == 's')) {
            s = 172;
          } else if ((LA18_60 == 'h')) {
            s = 70;
          } else if ((LA18_60 == 'H')) {
            s = 71;
          } else if (((LA18_60 >= '0' && LA18_60 <= '9'))) {
            s = 69;
          } else if (((LA18_60 >= 'a' && LA18_60 <= 'f'))) {
            s = 67;
          } else if (((LA18_60 >= 'A' && LA18_60 <= 'F'))) {
            s = 68;
          } else if ((LA18_60 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_60);
          if (s >= 0) return s;
          break;

        case 30:
          int LA18_5 = input.LA(1);

          int index18_5 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_5 == 'l')) {
            s = 85;
          } else if ((LA18_5 == 'n')) {
            s = 86;
          } else if ((LA18_5 == 'x')) {
            s = 87;
          } else if (((LA18_5 >= 'a' && LA18_5 <= 'f'))) {
            s = 67;
          } else if (((LA18_5 >= 'A' && LA18_5 <= 'F'))) {
            s = 68;
          } else if (((LA18_5 >= '0' && LA18_5 <= '9'))) {
            s = 69;
          } else if ((LA18_5 == 'h')) {
            s = 70;
          } else if ((LA18_5 == 'H')) {
            s = 71;
          } else if ((LA18_5 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_5);
          if (s >= 0) return s;
          break;

        case 31:
          int LA18_3 = input.LA(1);

          int index18_3 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_3 == 'a')) {
            s = 75;
          } else if ((LA18_3 == 'd')) {
            s = 76;
          } else if ((LA18_3 == 'l')) {
            s = 77;
          } else if ((LA18_3 == 'o')) {
            s = 78;
          } else if (((LA18_3 >= 'b' && LA18_3 <= 'c') || (LA18_3 >= 'e' && LA18_3 <= 'f'))) {
            s = 67;
          } else if (((LA18_3 >= 'A' && LA18_3 <= 'F'))) {
            s = 68;
          } else if (((LA18_3 >= '0' && LA18_3 <= '9'))) {
            s = 69;
          } else if ((LA18_3 == 'h')) {
            s = 70;
          } else if ((LA18_3 == 'H')) {
            s = 71;
          } else if ((LA18_3 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_3);
          if (s >= 0) return s;
          break;

        case 32:
          int LA18_54 = input.LA(1);
          s = -1;
          if (((LA18_54 >= '\u0000' && LA18_54 <= '\uFEFE')
              || (LA18_54 >= '\uFF00' && LA18_54 <= '\uFFFF'))) {
            s = 52;
          } else s = 165;
          if (s >= 0) return s;
          break;

        case 33:
          int LA18_6 = input.LA(1);

          int index18_6 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_6 == 'a')) {
            s = 88;
          } else if ((LA18_6 == 'i')) {
            s = 89;
          } else if ((LA18_6 == 'o')) {
            s = 90;
          } else if ((LA18_6 == 'u')) {
            s = 91;
          } else if (((LA18_6 >= 'b' && LA18_6 <= 'f'))) {
            s = 67;
          } else if (((LA18_6 >= 'A' && LA18_6 <= 'F'))) {
            s = 68;
          } else if (((LA18_6 >= '0' && LA18_6 <= '9'))) {
            s = 69;
          } else if ((LA18_6 == 'h')) {
            s = 70;
          } else if ((LA18_6 == 'H')) {
            s = 71;
          } else if ((LA18_6 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_6);
          if (s >= 0) return s;
          break;

        case 34:
          int LA18_53 = input.LA(1);

          int index18_53 = input.index();
          input.rewind();
          s = -1;
          if (((LA18_53 >= 'a' && LA18_53 <= 'f'))) {
            s = 67;
          } else if (((LA18_53 >= 'A' && LA18_53 <= 'F'))) {
            s = 68;
          } else if (((LA18_53 >= '0' && LA18_53 <= '9'))) {
            s = 69;
          } else if ((LA18_53 == 'h')) {
            s = 70;
          } else if ((LA18_53 == 'H')) {
            s = 71;
          } else if ((LA18_53 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_53);
          if (s >= 0) return s;
          break;

        case 35:
          int LA18_50 = input.LA(1);

          int index18_50 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_50 == 'L')) {
            s = 163;
          } else if (((LA18_50 >= 'a' && LA18_50 <= 'f'))) {
            s = 67;
          } else if (((LA18_50 >= 'A' && LA18_50 <= 'F'))) {
            s = 68;
          } else if (((LA18_50 >= '0' && LA18_50 <= '9'))) {
            s = 69;
          } else if ((LA18_50 == 'h')) {
            s = 70;
          } else if ((LA18_50 == 'H')) {
            s = 71;
          } else if ((LA18_50 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_50);
          if (s >= 0) return s;
          break;

        case 36:
          int LA18_49 = input.LA(1);

          int index18_49 = input.index();
          input.rewind();
          s = -1;
          if ((LA18_49 == 'N')) {
            s = 161;
          } else if ((LA18_49 == 'S')) {
            s = 162;
          } else if (((LA18_49 >= 'a' && LA18_49 <= 'f'))) {
            s = 67;
          } else if (((LA18_49 >= 'A' && LA18_49 <= 'F'))) {
            s = 68;
          } else if (((LA18_49 >= '0' && LA18_49 <= '9'))) {
            s = 69;
          } else if ((LA18_49 == 'h')) {
            s = 70;
          } else if ((LA18_49 == 'H')) {
            s = 71;
          } else if ((LA18_49 == ':') && ((asmMode))) {
            s = 72;
          } else s = 52;

          input.seek(index18_49);
          if (s >= 0) return s;
          break;
      }
      NoViableAltException nvae = new NoViableAltException(getDescription(), 18, _s, input);
      error(nvae);
      throw nvae;
    }
  }
}
