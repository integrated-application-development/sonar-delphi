<ruleset name="Delphi Default">
  <description>All rules</description>

  <!-- PRIORITY: 1 - blocker, 2 - critical, 3 - major, 4 - minor, 5 - info -->

  <rule class="org.sonar.plugins.delphi.pmd.rules.NoFunctionReturnTypeRule"
    message="Function return types should always be specified"
    name="NoFunctionReturnTypeRule">
    <priority>3</priority>
    <description>
      Delphi allows Function return types to be omitted in the implementation section. We have no
      desire to use this "feature".
      &lt;br&gt;
      Function return types should always be specified.
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
    <example>
      <![CDATA[
<b>function</b> TClass.Foo(Bar: Byte); // Noncompliant

<b>function</b> TClass.Foo(Bar: Byte): Integer;	// Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ClassPerFileRule"
    message="Files should not contain too many classes"
    name="ClassPerFileRule">
    <priority>3</priority>
    <description>A file should not include too many classes.</description>
    <properties>
      <property name="baseEffort" value="1h"/>
      <property name="limit" value="1"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.InheritedMethodWithNoCodeRule"
    message="Overriding methods should do more than simply call the same method in the super class"
    name="InheritedMethodWithNoCodeRule">
    <priority>3</priority>
    <description>
      Overriding a method just to call the same method from the super class without
      performing any other actions is useless and misleading.
    </description>
    <properties>
      <property name="baseEffort" value="10min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.SwallowedExceptionsRule"
    message="Exceptions should not be swallowed"
    name="SwallowedExceptionsRule">
    <priority>3</priority>
    <description>
      Exceptions should not be swallowed.
      &lt;br&gt;
      Exception handlers should contain logic to handle the caught exception.
    </description>
    <properties>
      <property name="baseEffort" value="10min"/>
      <property name="scope" value="MAIN"/>
      <property name="type" value="BUG"/>
    </properties>
    <example>
      <![CDATA[
<b>try</b>
  ThrowException;
<b>except</b>	// Noncompliant
  // Do nothing
<b>end;</b>

<b>try</b>
  ThrowException;
<b>except</b>	// Noncompliant
  <b>on</b> E: Exception <b>do begin</b>
    // Do nothing
  <b>end;</b>
<b>end;</b>

<b>try</b>
  ThrowException;
<b>except</b>	// Compliant
  <b>on</b> E: Exception <b>do begin</b>
    Log.Audit(<i>'He''s dead, Jim!'</i>);
  <b>end;</b>
<b>end;</b>
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.XPathBuiltinRule"
    message="'finally' blocks should not be empty"
    name="EmptyFinallyBlockRule">
    <priority>2</priority>
    <description>Empty finally blocks are superfluous.</description>
    <properties>
      <property name="baseEffort" value="5min"/>
      <property name="builtinXPath">
        <value>
          <![CDATA[
            //FinallyBlockNode[StatementListNode[count(*) = 0]]
          ]]>
        </value>
      </property>
    </properties>
    <example>
      <![CDATA[
<b>try</b>
  DoSomething;
<b>finally</b>	// Noncompliant
  // Do nothing
<b>end;</b>

<b>try</b>
  DoSomething;
<b>finally</b>	// Compliant
  Log.Info(<i>'All done!'</i>);
<b>end;</b>
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.EmptyInterfaceRule"
    message="Interface declarations should not be empty"
    name="EmptyInterfaceRule">
    <priority>3</priority>
    <description>Empty interface declarations are useless.</description>
    <properties>
      <property name="baseEffort" value="20min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.TooLargeMethodRule"
    message="Methods should not be too large"
    name="TooLargeMethodRule">
    <priority>2</priority>
    <description>A method that grow too large tends to aggregate too many responsibilities.
      Such methods inevitably become harder to understand and therefore harder to maintain.
      &lt;br&gt;
      &lt;br&gt;
      Above a specific threshold, it is strongly advised to refactor into smaller methods which
      focus on well-defined tasks.
      Those smaller methods will not only be easier to understand, but also easier to test.
    </description>
    <properties>
      <property name="baseEffort" value="30min"/>
      <property name="limit" value="100"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.TooManyArgumentsRule"
    message="Methods should not have too many arguments"
    name="TooManyArgumentsRule">
    <priority>3</priority>
    <description>
      A long parameter list can indicate that a new structure should be created to wrap
      the numerous parameters or that the method is doing too many things.
    </description>
    <properties>
      <property name="baseEffort" value="1h"/>
      <property name="limit" value="6"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.TooManyVariablesRule"
    message="Methods should not have too many variables"
    name="TooManyVariablesRule">
    <priority>3</priority>
    <description>
      Too many variables can indicate that a method is doing too many things.
    </description>
    <properties>
      <property name="baseEffort" value="30min"/>
      <property name="limit" value="10"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.XPathBuiltinRule"
    message="Method declarations should be followed by a semicolon"
    name="NoSemiAfterMethodDeclarationRule">
    <priority>3</priority>
    <description>
      Delphi syntax has corner cases which sometimes allow the semicolon to be omitted from the end
      of a method declaration.
      &lt;br&gt;
      Regardless, there should always be a semicolon ';' at the end of method declarations.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="5min"/>
      <property name="builtinXPath">
        <value>
          <![CDATA[
              //MethodHeadingNode/*[last()][@Image != ";"]
            ]]>
        </value>
      </property>
    </properties>
    <example>
      <![CDATA[
<b>procedure</b> Foo(Bar: Integer); <b>overload</b>	// Noncompliant

<b>procedure</b> Foo(Bar: Integer); <b>overload</b>; // Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.XPathBuiltinRule"
    message="Extraneous commas in argument lists should be removed"
    name="ExtraneousArgumentListCommasRule">
    <priority>1</priority>
    <description>
      Earlier versions of the Delphi parser (including XE3) allow a trailing comma in argument lists.
      &lt;br&gt;
      This is no longer permitted in Delphi Rio. Therefore, these extraneous commas should be removed.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
      <property name="builtinXPath">
        <value>
          <![CDATA[
              //ArgumentListNode/*[last() - 1][name() = "CommonDelphiNode" and @Image = ","]
            ]]>
        </value>
      </property>
    </properties>
    <example>
      <![CDATA[
Foo(1, 2, 3,); // Noncompliant

Foo(1, 2, 3); // Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.InterfaceNameRule"
    message="Interface names should comply with a naming convention"
    name="InterfaceNameRule">
    <priority>4</priority>
    <description>
      Interface names should begin with 'I' and follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.RecordNameRule"
    message="Record names should comply with a naming convention"
    name="RecordNameRule">
    <priority>4</priority>
    <description>
      Record names should begin with 'T' and follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="30min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.PointerNameRule"
    message="Pointer names should comply with a naming convention"
    name="PointerNameRule">
    <priority>4</priority>
    <description>
      Pointer names should be the same as the dereferenced type name, but with a 'P' replacing the
      'T'
      &lt;br&gt;
      &lt;br&gt;
      For example:
      &lt;br&gt;
      - ^TObject should be named PObject
      &lt;br&gt;
      - ^TType should be named PType
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="30min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.MethodNameRule"
    message="Method names should comply with a naming convention"
    name="MethodNameRule">
    <priority>4</priority>
    <description>
      Method names should follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="30min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.FieldNameRule"
    message="Field names should comply with a naming convention"
    name="FieldNameRule">
    <priority>4</priority>
    <description>
      Field names should begin with 'F' and follow Pascal case.
      &lt;br&gt;
      Published fields are excluded from this check due to Delphi's generated form fields.
    </description>
    <properties>
      <property name="baseEffort" value="5min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.UnitNameRule"
    message="Unit names should comply with a naming convention"
    name="UnitNameRule">
    <priority>4</priority>
    <description>
      Unit names should begin with 'om', 'F', 'Fr', or 'Frame', and follow Pascal Case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="30min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ConstantNotationRule"
    message="Constants should comply with a naming convention"
    name="ConstantNotationRule">
    <priority>4</priority>
    <description>
      Constants should begin with 'C_' and follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ClassNameRule"
    message="Class names should comply with a naming convention"
    name="ClassNameRule">
    <priority>4</priority>
    <description>
      Class names should begin with 'T', 'TForm', 'TFrame', or 'E', and follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.EnumNameRule"
    message="Enumeration names should comply with a naming convention"
    name="EnumNameRule">
    <priority>4</priority>
    <description>
      Enumeration names should begin with 'T' and follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ConstructorCreateRule"
    message="Constructor names should comply with a naming convention"
    name="ConstructorCreateRule">
    <priority>4</priority>
    <description>
      Constructor names should begin with 'Create' and follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.VariableNameRule"
    message="Variable names should comply with a naming convention"
    name="VariableNameRule">
    <priority>4</priority>
    <description>
      Variable names should follow Pascal case. Global variables should begin with 'G' and not
      contain underscores.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.CatchingGeneralExceptionRule"
    message="General exceptions should not be caught"
    name="CatchingGeneralExceptionRule">
    <priority>2</priority>
    <description>General exceptions should not be caught. Catch specific exception types instead.
    </description>
    <properties>
      <property name="baseEffort" value="15min"/>
    </properties>
    <example>
      <![CDATA[
<b>try</b>
  ThrowMyException;
<b>except</b>
  <b>on</b> e : Exception <b>do begin</b>	// Noncompliant
    HandleException;
  <b>end;</b>
<b>end;</b>

<b>try</b>
  ThrowMyException;
<b>except</b>
  <b>on</b> e : MyException <b>do begin</b> // Compliant
    HandleException;
  <b>end;</b>
<b>end;</b>
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.RaisingGeneralExceptionRule"
    message="General exceptions should not be raised"
    name="RaisingGeneralExceptionRule">
    <priority>2</priority>
    <description>General exceptions should not be raised. Instead, raise a specific exception
      type.
    </description>
    <properties>
      <property name="baseEffort" value="15min"/>
    </properties>
    <example>
      <![CDATA[
<b>raise</b> Exception.create(<i>'blah'</i>); // Noncompliant

<b>raise</b> MyException.create(<i>'blah'</i>); // Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.RedundantBooleanRule"
    message="Boolean literals should not be redundant"
    name="RedundantBooleanRule">
    <priority>4</priority>
    <description>Redundant Boolean literals should be removed from expressions to improve
      readability.
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
    <example>
      <![CDATA[
<b>if</b> Foo = True <b>then begin</b> // Noncompliant
  DoSomething;
<b>end;</b>

<b>if</b> Bar = False <b>then begin</b> // Noncompliant
  DoSomething;
<b>end;</b>

DoSomething(not False); // Noncompliant

<b>if</b> Foo <b>then begin</b> // Compliant
  DoSomething;
<b>end;</b>

<b>if</b> <b>not</b> Bar <b>then begin</b> // Compliant
  DoSomething;
<b>end;</b>

DoSomething(True); // Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.PublicFieldsRule"
    message="Fields should not have public visibility"
    name="PublicFieldsRule">
    <priority>3</priority>
    <description>Public fields do not respect the encapsulation principle. Use properties instead.
    </description>
    <properties>
      <property name="baseEffort" value="3min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.UnusedArgumentsRule"
    message="Unused method parameters should be removed"
    name="UnusedArgumentsRule">
    <priority>1</priority>
    <description>Unused parameters are misleading. Whatever the values passed to such parameters,
      the behavior will be the same.
    </description>
    <properties>
      <property name="baseEffort" value="5min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.XPathBuiltinRule"
    message="Interfaces should have unique GUIDs"
    name="NoGuidRule">
    <priority>3</priority>
    <description>Every interface should have a unique GUID.</description>
    <properties>
      <property name="baseEffort" value="5min"/>
      <property name="type" value="BUG"/>
      <property name="builtinXPath">
        <value>
          <![CDATA[
            //InterfaceTypeNode[count(child::*) > 0 and count(child::InterfaceGuidNode) = 0]
          ]]>
        </value>
      </property>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.AssignedAndFreeRule"
    message="Objects should not be checked for assignment before being freed"
    name="AssignedAndFreeRule">
    <priority>3</priority>
    <description>The TObject.Free method already checks for assignment before freeing. Additional
      checks are redundant.
    </description>
    <properties>
      <property name="baseEffort" value="5min"/>
    </properties>
    <example>
      <![CDATA[
<b>if</b> Assigned(Foo) <b>then begin</b> // Noncompliant
  Foo.Free;
<b>end;</b>

<b>if</b> Foo &lt;&gt; <b>nil</b> <b>then begin</b> // Noncompliant
  Foo.Free;
<b>end;</b>

<b>if</b> Assigned(Foo) <b>then begin</b> // Noncompliant
  FreeAndNil(Foo);
<b>end;</b>

<b>if</b> Foo &lt;&gt; <b>nil</b> <b>then begin</b> // Noncompliant
  FreeAndNil(Foo);
<b>end;</b>

Foo.Free; // Compliant

FreeAndNil(Foo); // Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.EmptyBeginStatementRule"
    message="Code blocks should not be empty"
    name="EmptyBeginStatementRule">
    <priority>4</priority>
    <description>
      Most of the time a block of code is empty when a piece of code is really missing. An empty
      block must be either filled or removed.
    </description>
    <properties>
      <property name="baseEffort" value="5min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.EmptyMethodRule"
    message="Methods should not be empty"
    name="EmptyMethodRule">
    <priority>3</priority>
    <description>
      Reasons for a method not to have a method body:
      &lt;br&gt;
      - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in
      production.
      &lt;br&gt;
      - It is an intentionally-blank override or virtual method. In this case a nested comment
      should explain the reason for the blank method.
      &lt;br&gt;
      &lt;br&gt;
      &lt;b&gt;Known false-positives:&lt;/b&gt;
      &lt;br&gt;
      - This rule does not detect if a method is an implementation for an interface.
      In the future, such implementations will be considered overrides and excluded if there is a
      comment inside.
    </description>
    <properties>
      <property name="baseEffort" value="5min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.DprFunctionRule"
    message="Project files should not have methods"
    name="ProjectFileNoFunctionsRule">
    <priority>3</priority>
    <description>Project files should not have methods.</description>
    <properties>
      <property name="baseEffort" value="15min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.DprVariableRule"
    message="Project files should not have variables"
    name="ProjectFileNoVariablesRule">
    <priority>3</priority>
    <description>Project files should not have variables.</description>
    <properties>
      <property name="baseEffort" value="15min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.TypeAliasRule"
    message="Track uses of type aliases"
    name="TypeAliasRule">
    <priority>5</priority>
    <description>
      Type aliases simply provide another name for a type.
      &lt;br&gt;
      When misused they can be misleading, confusing, and provide little value.
    </description>
    <properties>
      <property name="baseEffort" value="10min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.MixedNamesRule"
    message="Name casing should be kept consistent"
    name="MixedNamesRule">
    <priority>3</priority>
    <description>Delphi is case-insensitive, but casing of name declarations and references should
      be kept consistent.
    </description>
    <properties>
      <property name="baseEffort" value="5min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ConstructorWithoutInheritedStatementRule"
    message="Constructors should contain an 'inherited' statement"
    name="ConstructorWithoutInheritedStatementRule">
    <priority>3</priority>
    <description>Constructors should contain an 'inherited' statement.</description>
    <properties>
      <property name="baseEffort" value="5min"/>
      <property name="type" value="BUG"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.DestructorWithoutInheritedStatementRule"
    message="Destructors should contain an 'inherited' statement"
    name="DestructorWithoutInheritedStatementRule">
    <priority>3</priority>
    <description>
      Destructors should contain an 'inherited' statement. This also includes common
      destructor-like methods like Deinit and Teardown.
    </description>
    <properties>
      <property name="baseEffort" value="30min"/>
      <property name="type" value="BUG"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.BeginEndRequiredRule"
    message="'begin'..'end' should always be used"
    name="BeginEndRequiredRule">
    <priority>4</priority>
    <description>
      All compound statements should use 'begin'..'end', except for repeat statements.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="10min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.NoSemicolonRule"
    message="Statements should end in a semicolon"
    name="NoSemicolonRule">
    <priority>4</priority>
    <description>
      Semicolons are used as statement separators rather than statement terminators in Delphi's
      syntax.
      &lt;br&gt;
      As a result, the last semicolon in a code block is optional.
      &lt;br&gt;
      Regardless, each statement should be terminated with a semicolon.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.CastAndFreeRule"
    message="Objects should not be casted only to be freed"
    name="CastAndFreeRule">
    <priority>3</priority>
    <description>Casting an object only to free it is superfluous.</description>
    <properties>
      <property name="baseEffort" value="5min"/>
    </properties>
    <example>
      <![CDATA[
TMyObject(MyVar).Free; // Noncompliant
(MyVar <b>as</b> TMyObject).Free; // Noncompliant
MyVar.Free; // Compliant

FreeAndNil(TMyObject(MyVar)); // Noncompliant
FreeAndNil(MyVar <b>as</b> TMyObject); // Noncompliant
FreeAndNil(MyVar); // Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.CyclomaticComplexityRule"
    message="Cyclomatic complexity of methods should not be too high"
    name="MethodCyclomaticComplexityRule">
    <priority>2</priority>
    <description>
      The cyclomatic complexity of methods should not exceed a defined threshold.
      Complex code can perform poorly and will in any case be difficult to understand and therefore
      to maintain.
    </description>
    <properties>
      <property name="baseEffort" value="30min"/>
      <property name="limit" value="20"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.CognitiveComplexityRule"
    message="Cognitive complexity of methods should not be too high"
    name="MethodCognitiveComplexityRule">
    <priority>2</priority>
    <description>
      Cognitive Complexity is a measure of how hard the control flow of a method is to understand.
      Methods with high Cognitive Complexity will be difficult to maintain.
      &lt;br&gt;
      &lt;br&gt;
      &lt;b&gt;
      See:
      &lt;/b&gt;
      &lt;br&gt;
      - &lt;a href='https://www.sonarsource.com/docs/CognitiveComplexity.pdf'&gt;
      Cognitive Complexity
      &lt;/a&gt;
    </description>
    <properties>
      <property name="baseEffort" value="30min"/>
      <property name="limit" value="15"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.TooManySubProceduresRule"
    message="Methods should not contain too many sub-procedures"
    name="TooManySubProceduresRule">
    <priority>2</priority>
    <description>Methods should not contain too many sub-procedures. The limit is 3.</description>
    <properties>
      <property name="baseEffort" value="30min"/>
      <property name="limit" value="3"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.AvoidWithRule"
    message="'with' statements should not be used"
    name="AvoidWithRule">
    <priority>2</priority>
    <description>
      'with' statements should not be used.
      &lt;br&gt;
      They are difficult to debug, and make it easy to write ambiguous statements which may
      unexpectedly change meaning.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="5min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.TooLongLineRule"
    message="Lines should not be too long"
    name="TooLongLineRule">
    <priority>3</priority>
    <description>
      Having to scroll horizontally makes it harder to get a quick overview and understanding of any
      piece of code.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="2min"/>
      <property name="limit" value="120"/>
      <property name="scope" value="MAIN"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ReRaiseExceptionRule"
    message="Caught exceptions should not be explicitly re-raised"
    name="ReRaiseExceptionRule">
    <priority>1</priority>
    <description>
      You should never explicitly re-raise a caught exception.
      &lt;br&gt;
      The exception will still be freed at the end of the exception handler, causing tricky access
      violations.
      &lt;br&gt;
      Use 'raise;' instead of 'raise E;'.
      &lt;br&gt;
      &lt;br&gt;
      &lt;b&gt;
      See:
      &lt;/b&gt;
      &lt;br&gt;
      - &lt;a
      href='http://zerolith.com/delphi/on-delphi-exception-raising-re-raising-and-try-except-blocks.html'&gt;
      On Delphi Exception raising, re-raising and try-except blocks
      &lt;/a&gt;
      &lt;br&gt;
      - &lt;a href='http://delphi.org/2017/06/really-bad-exception-abuse/'&gt;
      Exceptionally Bad Exception Abuse
      &lt;/a&gt;
    </description>
    <properties>
      <property name="baseEffort" value="5min"/>
      <property name="type" value="BUG"/>
    </properties>
    <example>
      <![CDATA[
<b>on</b> E: Exception <b>do begin</b>
  Log.Debug(<i>'Exception message = '</i> + E.Message);
  <b>raise</b> E; // Noncompliant
<b>end;</b>

<b>on</b> E: Exception <b>do begin</b>
  Log.Debug(<i>'Exception message = '</i> + E.Message);
  <b>raise</b>; // Compliant
<b>end;</b>
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.EmptyBracketsRule"
    message="Methods should not be followed by empty brackets"
    name="EmptyBracketsRule">
    <priority>4</priority>
    <description>
      When calling or declaring a method, an empty argument or parameter list is superfluous and can
      be omitted.
      &lt;br&gt;
      This rule does not apply to procedural types or array constructors.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
    <example>
      <![CDATA[
FunctionWithoutArguments();	// Noncompliant

FunctionWithoutArguments;	// Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.DuplicatesRule"
    message="TStringLists should be sorted when setting Duplicates"
    name="DuplicatesRule">
    <priority>1</priority>
    <description>
      TStringLists must be sorted if setting the Duplicates property.
      &lt;br&gt;
      For the purposes of this rule, the list must be sorted on the next or previous line.
      &lt;br&gt;
      &lt;br&gt;
      &lt;b&gt;
      See:
      &lt;/b&gt;
      &lt;br&gt;
      - &lt;a
      href='http://docwiki.embarcadero.com/Libraries/XE3/en/System.Classes.TStringList.Duplicates'&gt;
      API Documentation
      &lt;/a&gt;
    </description>
    <properties>
      <property name="baseEffort" value="2min"/>
      <property name="type" value="BUG"/>
    </properties>
    <example>
      <![CDATA[
List1.Duplicates := <i>dupIgnore</i>; // Noncompliant

List2.Duplicates := <i>dupError</i>; // Noncompliant

List3.Duplicates := <i>dupAccept</i>; // Compliant (dupAccept doesn't require a sorted list)

List4.Sorted := True;
List4.Duplicates := <i>dupIgnore</i>; // Compliant

List5.Sorted := True;
List5.Duplicates := <i>dupError</i>; // Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.LowerCaseReservedWordsRule"
    message="Keywords should be lowercase"
    name="LowerCaseReservedWordsRule">
    <priority>3</priority>
    <description>
      Reserved keywords should always be lowercase.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ShortIdentifiersRule"
    message="Identifiers should not be too short"
    name="ShortIdentifiersRule">
    <priority>3</priority>
    <description>
      When an identifier is too short, it isn't immediately obvious what it's for. Identifiers
      should be given meaningful names.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="5min"/>
      <property name="limit" value="3"/>
      <property name="whitelist" value="E|X|Y|ID|Id"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.MemoryManagementRule"
    message="Memory management should be used"
    name="MemoryManagementRule">
    <priority>2</priority>
    <description>
      Memory management methods should be used to manage object lifecycles.
      &lt;br&gt;
      Because interface types are already reference-counted, this rule will exclude assignments to
      interface variables or arguments supplied to a method expecting an interface instance.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="10min"/>
      <property name="memoryFunctions" value="Local|Managed|ManagedBy|ManagedInterface|Unmanaged"/>
      <property name="whitelist" value="CreateNew"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.MethodNestingDepthRule"
    message="Methods should not be nested too deeply"
    name="MethodNestingDepthRule">
    <priority>3</priority>
    <description>
      Deeply nested methods make the code difficult to navigate/read.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="10min"/>
      <property name="depth" value="1"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ExplicitTObjectRule"
    message="Top-level classes should explicitly inherit from TObject"
    name="ExplicitTObjectRule">
    <priority>4</priority>
    <description>
      A class without a parent will implicitly inherit from TObject.
      The explicit form is recommended by Embarcadero for readability.
      &lt;br&gt;
      &lt;br&gt;
      For more information, see the Delphi wiki page for
      &lt;a
      href='http://docwiki.embarcadero.com/RADStudio/Rio/en/Classes_and_Objects_(Delphi)#TObject_and_TClass'&gt;
      TObject and TClass
      &lt;/a&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.DestructorDestroyRule"
    message="Destructors should override TObject.Destroy"
    name="DestructorDestroyRule">
    <priority>3</priority>
    <description>
      Destroy is a virtual destructor of TObject.
      &lt;br&gt;
      When an object is destroyed, TObject.Free calls the Destroy virtual destructor of the specific
      class.
      &lt;br&gt;
      With this behavior in mind, destructors should always override TObject.Destroy.
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
      <property name="type" value="BUG"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.CaseStatementSizeRule"
    message="Case statements should have at least 2 case items"
    name="CaseStatementSizeRule">
    <priority>4</priority>
    <description>
      A case statement with less than 2 case items would be better expressed as an if-statement.
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.MultipleVariableDeclarationRule"
    message="Variables should be declared individually"
    name="MultipleVariableDeclarationRule">
    <priority>4</priority>
    <description>
      Variables and fields should be defined one per line of code.
      &lt;br&gt;
      Individual parameters should have their types explicitly declared.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.TabulationCharactersRule"
    message="Tabulation characters should not be used"
    name="TabulationCharactersRule">
    <priority>5</priority>
    <description>
      Developers should not need to configure the tab width of their text editors in order to be
      able to read source code.
      &lt;br&gt;
      So the use of the tabulation character must be banned.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.AssignedNilCheckRule"
    message="Nil checks should be performed with Assigned"
    name="AssignedNilCheckRule">
    <priority>4</priority>
    <description>
      Use 'Assigned' instead of comparing to nil.
      &lt;br&gt;
      &lt;br&gt;
      For more information, see the Delphi wiki page for
      &lt;a href='http://docwiki.embarcadero.com/Libraries/Rio/en/System.Assigned'&gt;
      System.Assigned
      &lt;/a&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.RedundantParenthesesRule"
    message="Redundant pairs of parentheses should be removed"
    name="RedundantParenthesesRule">
    <priority>4</priority>
    <description>
      The use of parentheses, even those not required to enforce a desired order of operations,
      can clarify the intent behind a piece of code. But redundant pairs of parentheses could be
      misleading, and should be removed.
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
    <example>
      <![CDATA[
Result := X + 1; // Compliant

Result := (X + 1); // Compliant

Result := ((X + 1)); // Noncompliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.SuperfluousSemicolonsRule"
    message="Stray semicolons should be removed"
    name="SuperfluousSemicolonsRule">
    <priority>4</priority>
    <description>
      Stray semicolons are usually introduced by mistake, for example because:
      &lt;br&gt;
      - It was meant to be replaced by an actual statement, but this was forgotten.
      &lt;br&gt;
      - There was a typo which lead the semicolon to be doubled, i.e ;;.
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
    </properties>
    <example>
      <![CDATA[
Result := 123; // Compliant

Result := 123;; // Noncompliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.CommentedOutCodeRule"
    message="Sections of code should not be commented out"
    name="CommentedOutCodeRule">
    <priority>4</priority>
    <description>
      Programmers should not comment out code as it bloats programs and reduces readability.
      &lt;br&gt;
      &lt;br&gt;
      Unused code should be deleted and can be retrieved from source control history if required.
      &lt;br&gt;
      &lt;br&gt;
      NOTE: Please be mindful of the fact that certain comments, such as a single word followed by a
      semicolon, are indistinguishable from Delphi code and will be flagged.
    </description>
    <properties>
      <property name="baseEffort" value="3min"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.XPathBuiltinRule"
    message="Empty type sections should be removed"
    name="EmptyTypeSectionRule">
    <priority>4</priority>
    <description>
      Empty type sections are superfluous and can be safely removed.
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
      <property name="builtinXPath">
        <value>
          <![CDATA[
            //TypeSectionNode[count(*) = 0]
          ]]>
        </value>
      </property>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.XPathBuiltinRule"
    message="Empty visibility sections should be removed"
    name="EmptyVisibilitySectionRule">
    <priority>4</priority>
    <description>
      Empty visibility sections are superfluous and can be safely removed.
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
      <property name="builtinXPath">
        <value>
          <![CDATA[
            //VisibilitySectionNode[@Visibility != 'IMPLICIT_PUBLISHED' and count(*) = 1]
          ]]>
        </value>
      </property>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.XPathBuiltinRule"
    message="Empty field sections should be removed"
    name="EmptyFieldSectionRule">
    <priority>4</priority>
    <description>
      Empty field sections are superfluous and can be safely removed.
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
      <property name="builtinXPath">
        <value>
          <![CDATA[
            //FieldSectionNode[count(FieldDeclarationNode) = 0]
          ]]>
        </value>
      </property>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.XPathBuiltinRule"
    message="Object types should not be used"
    name="ObjectTypeRule">
    <priority>4</priority>
    <description>
      Object types are supported for backward compatibility only. Their use is not recommended.
      &lt;br&gt;
      &lt;br&gt;
      For more information on Object types, see the Delphi wiki page for
      &lt;a
      href='http://docwiki.embarcadero.com/RADStudio/Rio/en/Classes_and_Objects_(Delphi)#Object_Types'&gt;
      Classes and Objects
      &lt;/a&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
      <property name="builtinXPath">
        <value>
          <![CDATA[
            //TypeDeclarationNode[@Object = 'true']/SimpleNameDeclarationNode
          ]]>
        </value>
      </property>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.XPathTemplateRule"
    message="Track breaches of an XPath rule"
    name="XPathRule">
    <priority>3</priority>
    <description>Track breaches of an XPath rule</description>
    <properties>
      <property name="baseEffort" value="5min"/>
      <property name="template" value="true"/>
      <property name="xpath"/>
      <property name="message"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ForbiddenIdentifierRule"
    message="Track uses of disallowed identifiers"
    name="ForbiddenIdentifierRule">
    <priority>3</priority>
    <description>
      This rule template can be used to create rules which will be triggered when a name is declared
      that matches an item in the blacklist.
    </description>
    <properties>
      <property name="baseEffort" value="5min"/>
      <property name="template" value="true"/>
      <property name="blacklist"/>
      <property name="message"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ForbiddenMethodRule"
    message="Track uses of disallowed methods"
    name="ForbiddenMethodRule">
    <priority>3</priority>
    <description>
      This rule allows banning certain methods.
      It will flag any direct reference to a method from the blacklist.
      &lt;br&gt;
      &lt;br&gt;
      Please note:
      &lt;br&gt;
      - A fully qualified method name is required. (E.g. "Unit.Type.Method")
      &lt;br&gt;
      - All overloads will be tracked. Parameter signatures cannot be specified.
    </description>
    <properties>
      <property name="baseEffort" value="5min"/>
      <property name="template" value="true"/>
      <property name="blacklist"/>
      <property name="message"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ForbiddenTypeRule"
    message="Track uses of disallowed types"
    name="ForbiddenTypeRule">
    <priority>3</priority>
    <description>
      This rule allows banning certain types.
      It will flag any direct reference to a type from the blacklist.
      &lt;br&gt;
      Please note that a fully qualified type name is required. (E.g. "Unit.Type.InnerType")
    </description>
    <properties>
      <property name="baseEffort" value="10min"/>
      <property name="template" value="true"/>
      <property name="blacklist"/>
      <property name="message"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.CommentRegexRule"
    message="Track comments matching a regular expression"
    name="CommentRegexRule">
    <priority>3</priority>
    <description>
      This rule template can be used to create rules which will be triggered when the full content
      of a comment matches a given regular expression.
      Note that the regular expression should be expressed using the dotall format
      (where the &lt;code&gt;.&lt;/code&gt; character matches any character).
      &lt;br&gt;
      &lt;br&gt;
      For example, one can create a rule with the regular expression &lt;code&gt;.*REVIEW.*&lt;/code&gt;
      to match all comments containing "REVIEW".
      &lt;br&gt;
      &lt;br&gt;
      Note that, in order to match REVIEW regardless of the case, the &lt;code&gt;(?i)&lt;/code&gt;
      modifier should be
      prepended to the expression, as in &lt;code&gt;(?i).*REVIEW.*&lt;/code&gt;.
    </description>
    <properties>
      <property name="baseEffort" value="20min"/>
      <property name="template" value="true"/>
      <property name="regex"/>
      <property name="message"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.StringLiteralRegexRule"
    message="Track string literals matching a regular expression"
    name="StringLiteralRegexRule">
    <priority>3</priority>
    <description>
      This rule template can be used to create rules which will be triggered when the full content
      of a string literal matches a given regular expression.
      Note that the regular expression should be expressed using the dotall format
      (where the &lt;code&gt;.&lt;/code&gt; character matches any character).
      &lt;br&gt;
      &lt;br&gt;
      For example, one can create a rule with the regular expression &lt;code&gt;.*REVIEW.*&lt;/code&gt;
      to match all strings containing "REVIEW".
      &lt;br&gt;
      &lt;br&gt;
      Note that, in order to match REVIEW regardless of the case, the &lt;code&gt;(?i)&lt;/code&gt;
      modifier should be
      prepended to the expression, as in &lt;code&gt;(?i).*REVIEW.*&lt;/code&gt;.
    </description>
    <properties>
      <property name="baseEffort" value="20min"/>
      <property name="template" value="true"/>
      <property name="scope" value="MAIN"/>
      <property name="regex"/>
      <property name="message"/>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.InheritedTypeNameRule"
    message="Types which inherit from some other specified type should comply with a naming convention"
    name="InheritedTypeNameRule">
    <priority>3</priority>
    <description>
      This rule template can be used to enforce naming convention on a type which inherits from some
      other type.
      &lt;br&gt;
      Please note that this only supports direct inheritance and does not traverse the inheritance
      tree.
    </description>
    <properties>
      <property name="baseEffort" value="1min"/>
      <property name="template" value="true"/>
      <property name="nameRegex"/>
      <property name="parentNameRegex"/>
      <property name="message"/>
    </properties>
  </rule>
</ruleset>
