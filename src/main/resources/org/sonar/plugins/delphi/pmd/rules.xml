<ruleset name="Delphi Default">
  <description>All rules</description>

  <!-- PRIORITY: 1 - blocker, 2 - critical, 3 - major, 4 - minor, 5 - info -->

  <rule class="org.sonar.plugins.delphi.pmd.rules.NoFunctionReturnTypeRule"
        message="Function return types should always be specified"
        name="NoFunctionReturnTypeRule">
    <priority>3</priority>
    <description>
      Delphi allows Function return types to be omitted in the implementation section. We have no desire to use this "feature".
      &lt;br&gt;
      Function return types should always be specified.
    </description>
    <properties>
      <property name="baseEffort" value="1min" />
    </properties>
    <example>
      <![CDATA[
<b>function</b> TClass.Foo(Bar: Byte); // Noncompliant

<b>function</b> TClass.Foo(Bar: Byte): Integer;	// Compliant
        ]]>
     </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ClassPerFileRule"
        message="Files should not contain too many classes"
        name="ClassPerFileRule">
    <priority>3</priority>
    <description>A file should not include too many classes.</description>
    <properties>
      <property name="baseEffort" value="1h" />
      <property name="limit" value="1" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.InheritedMethodWithNoCodeRule"
        message="Overriding methods should do more than simply call the same method in the super class"
        name="InheritedMethodWithNoCodeRule">
    <priority>3</priority>
    <description>
      Overriding a method just to call the same method from the super class without
      performing any other actions is useless and misleading.
    </description>
    <properties>
      <property name="baseEffort" value="10min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.SwallowedExceptionsRule"
        message="Exceptions should not be swallowed"
        name="SwallowedExceptionsRule">
    <priority>2</priority>
    <description>
      Exceptions should not be swallowed.
      &lt;br&gt;
      Exception handlers should contain logic to handle the caught exception.
    </description>
    <properties>
      <property name="baseEffort" value="10min" />
      <property name="scope" value="MAIN" />
      <property name="type" value="BUG" />
    </properties>
    <example>
      <![CDATA[
<b>try</b>
  ThrowException;
<b>except</b>	// Noncompliant
  // Do nothing
<b>end;</b>

<b>try</b>
  ThrowException;
<b>except</b>	// Noncompliant
  <b>on</b> E: Exception <b>do begin</b>
    // Do nothing
  <b>end;</b>
<b>end;</b>

<b>try</b>
  ThrowException;
<b>except</b>	// Compliant
  <b>on</b> E: Exception <b>do begin</b>
    Log.Error(<i>'He''s dead, Jim!'</i>);
  <b>end;</b>
<b>end;</b>
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.XPathBuiltinRule"
        message="'finally' blocks should not be empty"
        name="EmptyFinallyBlockRule">
    <priority>2</priority>
    <description>Empty finally blocks are superfluous.</description>
    <properties>
      <property name="baseEffort" value="5min" />
      <property name="builtinXPath">
        <value>
          <![CDATA[
            //FinallyBlockNode[StatementListNode[count(*) = 0]]
          ]]>
        </value>
      </property>
    </properties>
    <example>
      <![CDATA[
<b>try</b>
  DoSomething;
<b>finally</b>	// Noncompliant
  // Do nothing
<b>end;</b>

<b>try</b>
  DoSomething;
<b>finally</b>	// Compliant
  Log.Info(<i>'All done!'</i>);
<b>end;</b>
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.EmptyInterfaceRule"
        message="Interface declarations should not be empty"
        name="EmptyInterfaceRule">
    <priority>3</priority>
    <description>Empty interface declarations are useless.</description>
    <properties>
      <property name="baseEffort" value="20min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.TooLargeMethodRule"
        message="Methods should not be too large"
        name="TooLargeMethodRule">
    <priority>2</priority>
    <description>A method that grow too large tends to aggregate too many responsibilities.
      Such methods inevitably become harder to understand and therefore harder to maintain.
      &lt;br&gt;
      &lt;br&gt;
      Above a specific threshold, it is strongly advised to refactor into smaller methods which focus on well-defined tasks.
      Those smaller methods will not only be easier to understand, but also easier to test.
    </description>
    <properties>
      <property name="baseEffort" value="30min" />
      <property name="limit" value="100" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.TooManyArgumentsRule"
        message="Methods should not have too many arguments"
        name="TooManyArgumentsRule">
    <priority>3</priority>
    <description>
      A long parameter list can indicate that a new structure should be created to wrap
      the numerous parameters or that the method is doing too many things.
    </description>
    <properties>
      <property name="baseEffort" value="1h" />
      <property name="limit" value="6" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.TooManyVariablesRule"
        message="Methods should not have too many variables"
        name="TooManyVariablesRule">
    <priority>3</priority>
    <description>
      Too many variables can indicate that a method is doing too many things.</description>
    <properties>
      <property name="baseEffort" value="30min" />
      <property name="limit" value="10" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.XPathBuiltinRule"
    message="Method declarations should be followed by a semicolon"
    name="NoSemiAfterMethodDeclarationRule">
    <priority>3</priority>
    <description>
      Delphi syntax has corner cases which sometimes allow the semicolon to be omitted from the end of a method declaration.
      &lt;br&gt;
      Regardless, there should always be a semicolon ';' at the end of method declarations.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="5min" />
      <property name="builtinXPath">
        <value>
          <![CDATA[
              //MethodHeadingNode/*[last()][@Image != ";"]
            ]]>
        </value>
      </property>
    </properties>
    <example>
      <![CDATA[
<b>procedure</b> Foo(Bar: Integer); <b>overload</b>	// Noncompliant

<b>procedure</b> Foo(Bar: Integer); <b>overload</b>; // Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.InterfaceNameRule"
        message="Interface names should comply with a naming convention"
        name="InterfaceNameRule">
    <priority>4</priority>
    <description>
      Interface names should begin with 'I' and follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.RecordNameRule"
        message="Record names should comply with a naming convention"
        name="RecordNameRule">
    <priority>4</priority>
    <description>
      Record names should begin with 'T' and follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="30min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.PointerNameRule"
        message="Pointer names should comply with a naming convention"
        name="PointerNameRule">
    <priority>4</priority>
    <description>
      Pointer names should begin with 'P' and follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="30min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.MethodNameRule"
        message="Method names should comply with a naming convention"
        name="MethodNameRule">
    <priority>4</priority>
    <description>
      Method names should follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="30min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.FieldNameRule"
        message="Field names should comply with a naming convention"
        name="FieldNameRule">
    <priority>4</priority>
    <description>
      Field names should begin with 'F' and follow Pascal case.
      &lt;br&gt;
      Published fields are excluded from this check due to Delphi's generated form fields.
    </description>
    <properties>
      <property name="baseEffort" value="5min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.UnitNameRule"
        message="Unit names should comply with a naming convention"
        name="UnitNameRule">
    <priority>4</priority>
    <description>Unit name should follow Pascal Case.</description>
    <properties>
      <property name="baseEffort" value="30min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ConstantNotationRule"
    message="Constants should comply with a naming convention"
    name="ConstantNotationRule">
    <priority>4</priority>
    <description>
      Constants should begin with 'C_' and follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ClassNameRule"
    message="Class and names should comply with a naming convention"
    name="ClassNameRule">
    <priority>4</priority>
    <description>
      Class names should begin with 'T', 'TForm', 'TFrame', or 'E', and follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.EnumNameRule"
    message="Enumeration names should comply with a naming convention"
    name="EnumNameRule">
    <priority>4</priority>
    <description>
      Enumeration names should begin with 'T' and follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ConstructorCreateRule"
    message="Constructor names should comply with a naming convention"
    name="ConstructorCreateRule">
    <priority>4</priority>
    <description>
      Constructor names should begin with 'Create' and follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.VariableNameRule"
    message="Variable names should comply with a naming convention"
    name="VariableNameRule">
    <priority>4</priority>
    <description>
      Variable names should follow Pascal case.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.CatchingGeneralExceptionRule"
        message="General exceptions should not be caught"
        name="CatchingGeneralExceptionRule">
    <priority>2</priority>
    <description>General exceptions should not be caught. Catch specific exception types instead.</description>
    <properties>
      <property name="baseEffort" value="15min" />
    </properties>
    <example>
      <![CDATA[
<b>try</b>
  ThrowMyException;
<b>except</b>
  <b>on</b> e : Exception <b>do begin</b>	// Noncompliant
    HandleException;
  <b>end;</b>
<b>end;</b>

<b>try</b>
  ThrowMyException;
<b>except</b>
  <b>on</b> e : MyException <b>do begin</b> // Compliant
    HandleException;
  <b>end;</b>
<b>end;</b>
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.RaisingGeneralExceptionRule"
        message="General exceptions should not be raised"
        name="RaisingGeneralExceptionRule">
    <priority>2</priority>
    <description>General exceptions should not be raised. Instead, raise a specific exception type.</description>
    <properties>
      <property name="baseEffort" value="15min" />
    </properties>
    <example>
      <![CDATA[
<b>raise</b> Exception.create(<i>'blah'</i>); // Noncompliant

<b>raise</b> MyException.create(<i>'blah'</i>); // Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.RedundantBooleanRule"
        message="Boolean literals should not be redundant"
        name="RedundantBooleanRule">
    <priority>3</priority>
    <description>Redundant Boolean literals should be removed from expressions to improve readability.</description>
    <properties>
      <property name="baseEffort" value="1min" />
    </properties>
    <example>
      <![CDATA[
<b>if</b> Foo = True <b>then begin</b> // Noncompliant
  DoSomething;
<b>end;</b>

<b>if</b> Bar = False <b>then begin</b> // Noncompliant
  DoSomething;
<b>end;</b>

DoSomething(not False); // Noncompliant

<b>if</b> Foo <b>then begin</b> // Compliant
  DoSomething;
<b>end;</b>

<b>if</b> <b>not</b> Bar <b>then begin</b> // Compliant
  DoSomething;
<b>end;</b>

DoSomething(True); // Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.PublicFieldsRule"
        message="Fields should not have public visibility"
        name="PublicFieldsRule">
    <priority>3</priority>
    <description>Public fields do not respect the encapsulation principle. Use properties instead.</description>
    <properties>
      <property name="baseEffort" value="3min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.UnusedArgumentsRule"
        message="Unused method parameters should be removed"
        name="UnusedArgumentsRule">
    <priority>1</priority>
    <description>Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same.</description>
    <properties>
      <property name="baseEffort" value="5min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.XPathBuiltinRule"
        message="Interfaces should have unique GUIDs"
        name="NoGuidRule">
    <priority>3</priority>
    <description>Every interface should have a unique GUID.</description>
    <properties>
      <property name="baseEffort" value="5min" />
      <property name="type" value="BUG" />
      <property name="builtinXPath">
        <value>
          <![CDATA[
            //InterfaceTypeNode[count(child::*) > 0 and count(child::InterfaceGuidNode) = 0]
          ]]>
        </value>
      </property>
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.AssignedAndFreeRule"
        message="Objects should not be checked for assignment before being freed"
        name="AssignedAndFreeRule">
    <priority>3</priority>
    <description>The TObject.Free method already checks for assignment before freeing. Additional checks are redundant.</description>
    <properties>
      <property name="baseEffort" value="5min" />
    </properties>
    <example>
      <![CDATA[
<b>if</b> <b>Assigned</b>(Foo) <b>then begin</b> // Noncompliant
  Foo.Free;
<b>end;</b>

<b>if</b> Foo &lt;&gt; <b>nil</b> <b>then begin</b> // Noncompliant
  Foo.Free;
<b>end;</b>

<b>if</b> <b>Assigned</b>(Foo) <b>then begin</b> // Noncompliant
  FreeAndNil(Foo);
<b>end;</b>

<b>if</b> Foo &lt;&gt; <b>nil</b> <b>then begin</b> // Noncompliant
  FreeAndNil(Foo);
<b>end;</b>

Foo.Free; // Compliant

FreeAndNil(Foo); // Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.EmptyBeginStatementRule"
        message="Code blocks should not be empty"
        name="EmptyBeginStatementRule">
    <priority>4</priority>
    <description>Empty code blocks are not allowed.</description>
    <properties>
      <property name="baseEffort" value="5min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.EmptyMethodRule"
    message="Methods should not be empty"
    name="EmptyMethodRule">
    <priority>3</priority>
    <description>
      Reasons for a method not to have a method body:
      &lt;br&gt;
      - It is an unintentional omission, and should be fixed.
      &lt;br&gt;
      - It is an intentionally-blank override or virtual method. In this case, a nested comment should explain the reason for the blank method.
    </description>
    <properties>
      <property name="baseEffort" value="5min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.DprFunctionRule"
        message="Project files should not have methods"
        name="ProjectFileNoFunctionsRule">
    <priority>3</priority>
    <description>Project files should not have methods.</description>
    <properties>
      <property name="baseEffort" value="15min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.DprVariableRule"
        message="Project files should not have variables"
        name="ProjectFileNoVariablesRule">
    <priority>3</priority>
    <description>Project files should not have variables.</description>
    <properties>
      <property name="baseEffort" value="15min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.TypeAliasRule"
        message="Track uses of type aliases"
        name="TypeAliasRule">
    <priority>5</priority>
    <description>Track uses of type aliases.</description>
    <properties>
      <property name="baseEffort" value="10min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.MixedNamesRule"
        message="Name casing should be kept consistent"
        name="MixedNamesRule">
    <priority>3</priority>
    <description>Delphi is case-insensitive, but casing of name declarations and references should be kept consistent.</description>
    <properties>
      <property name="baseEffort" value="5min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ConstructorWithoutInheritedStatementRule"
        message="Constructors should contain an 'inherited' statement"
        name="ConstructorWithoutInheritedStatementRule">
    <priority>2</priority>
    <description>Constructors should contain an 'inherited' statement.</description>
    <properties>
      <property name="baseEffort" value="5min" />
      <property name="type" value="BUG" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.DestructorWithoutInheritedStatementRule"
        message="Destructors should contain an 'inherited' statement"
        name="DestructorWithoutInheritedStatementRule">
    <priority>2</priority>
    <description>Destructors should contain an 'inherited' statement.</description>
    <properties>
      <property name="baseEffort" value="30min" />
      <property name="type" value="BUG" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.BeginEndRequiredRule"
        message="'begin'..'end' should always be used"
        name="BeginEndRequiredRule">
    <priority>4</priority>
    <description>
      All compound statements should use 'begin'..'end', except for repeat statements.
      &lt;br&gt;
      &lt;br&gt;</description>
    <properties>
      <property name="baseEffort" value="10min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.NoSemicolonRule"
        message="Statements should end in a semicolon"
        name="NoSemicolonRule">
    <priority>4</priority>
    <description>
      Semicolons are used as statement separators rather than statement terminators in Delphi's syntax.
      &lt;br&gt;
      As a result, the last semicolon in a code block is optional.
      &lt;br&gt;
      Regardless, each statement should be terminated with a semicolon.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.CastAndFreeRule"
        message="Objects should not be casted only to be freed"
        name="CastAndFreeRule">
    <priority>3</priority>
    <description>Casting an object only to free it is superfluous.</description>
    <properties>
      <property name="baseEffort" value="5min" />
    </properties>
    <example>
      <![CDATA[
TMyObject(MyVar).Free; // Noncompliant
(MyVar <b>as</b> TMyObject).Free; // Noncompliant
MyVar.Free; // Compliant

FreeAndNil(TMyObject(MyVar)); // Noncompliant
FreeAndNil(MyVar <b>as</b> TMyObject); // Noncompliant
FreeAndNil(MyVar); // Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.CyclomaticComplexityRule"
        message="Cyclomatic complexity of methods should not be too high"
        name="MethodCyclomaticComplexityRule">
    <priority>2</priority>
    <description>
      The cyclomatic complexity of methods should not exceed a defined threshold.
      Complex code can perform poorly and will in any case be difficult to understand and therefore to maintain.
    </description>
    <properties>
      <property name="baseEffort" value="30min" />
      <property name="limit" value="20" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.CognitiveComplexityRule"
    message="Cognitive complexity of methods should not be too high"
    name="MethodCognitiveComplexityRule">
    <priority>2</priority>
    <description>
      Cognitive Complexity is a measure of how hard the control flow of a method is to understand.
      Methods with high Cognitive Complexity will be difficult to maintain.
      &lt;br&gt;
      &lt;br&gt;
      &lt;b&gt;See:&lt;/b&gt;
      &lt;br&gt;
      - &lt;a href='https://www.sonarsource.com/docs/CognitiveComplexity.pdf'&gt;
      Cognitive Complexity
      &lt;/a&gt;
    </description>
    <properties>
      <property name="baseEffort" value="30min" />
      <property name="limit" value="15" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.TooManySubProceduresRule"
        message="Methods should not contain too many sub-procedures"
        name="TooManySubProceduresRule">
    <priority>2</priority>
      <description>Methods should not contain too many sub-procedures. The limit is 3.</description>
      <properties>
        <property name="baseEffort" value="30min" />
        <property name="limit" value="3" />
      </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.AvoidWithRule"
        message="'with' statements should not be used"
        name="AvoidWithRule">
    <priority>2</priority>
    <description>
      'with' statements should not be used.
      &lt;br&gt;
      They are difficult to debug, and make it easy to write ambiguous statements which may unexpectedly change meaning.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="5min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.TooLongLineRule"
        message="Lines should not be too long"
        name="TooLongLineRule">
    <priority>3</priority>
    <description>
      Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="2min" />
      <property name="limit" value="100" />
      <property name="scope" value="MAIN" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.ReRaiseExceptionRule"
        message="Caught exceptions should not be explicitly re-raised"
        name="ReRaiseExceptionRule">
    <priority>1</priority>
    <description>
      You should never explicitly re-raise a caught exception.
      &lt;br&gt;
      The exception will still be freed at the end of the exception handler, causing tricky access violations.
      &lt;br&gt;
      Use 'raise;' instead of 'raise E;'.
      &lt;br&gt;
      &lt;br&gt;
      &lt;b&gt;See:&lt;/b&gt;
      &lt;br&gt;
      - &lt;a href='http://zerolith.com/delphi/on-delphi-exception-raising-re-raising-and-try-except-blocks.html'&gt;
        On Delphi Exception raising, re-raising and try-except blocks
      &lt;/a&gt;
      &lt;br&gt;
      - &lt;a href='http://delphi.org/2017/06/really-bad-exception-abuse/'&gt;
        Exceptionally Bad Exception Abuse
      &lt;/a&gt;
    </description>
    <properties>
      <property name="baseEffort" value="5min" />
      <property name="type" value="BUG" />
    </properties>
    <example>
      <![CDATA[
<b>on</b> E: Exception <b>do begin</b>
  Log.Debug(<i>'Exception message = '</i> + E.Message);
  <b>raise</b> E; // Noncompliant
<b>end;</b>

<b>on</b> E: Exception <b>do begin</b>
  Log.Debug(<i>'Exception message = '</i> + E.Message);
  <b>raise</b>; // Compliant
<b>end;</b>
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.EmptyBracketsRule"
        message="Methods should not be followed by empty brackets"
        name="EmptyBracketsRule">
    <priority>4</priority>
    <description>
      When calling or declaring a method, an empty argument or parameter list is superfluous and can be omitted.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min" />
    </properties>
    <example>
      <![CDATA[
FunctionWithoutArguments();	// Noncompliant

FunctionWithoutArguments;	// Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.DuplicatesRule"
        message="TStringLists should be sorted when setting Duplicates"
        name="DuplicatesRule">
    <priority>2</priority>
    <description>
      TStringLists must be sorted if setting the Duplicates property.
      &lt;br&gt;
      For the purposes of this rule, the list must be sorted on the next or previous line.
      &lt;br&gt;
      &lt;br&gt;
      &lt;b&gt;See:&lt;/b&gt;
      &lt;br&gt;
      - &lt;a href='http://docwiki.embarcadero.com/Libraries/XE3/en/System.Classes.TStringList.Duplicates'&gt;API Documentation&lt;/a&gt;
    </description>
    <properties>
      <property name="baseEffort" value="2min" />
      <property name="type" value="BUG" />
    </properties>
    <example>
      <![CDATA[
List1.Duplicates := <i>dupIgnore</i>; // Noncompliant

List2.Duplicates := <i>dupError</i>; // Noncompliant

List3.Duplicates := <i>dupAccept</i>; // Compliant (dupAccept doesn't require a sorted list)

List4.Sorted := True;
List4.Duplicates := <i>dupIgnore</i>; // Compliant

List5.Sorted := True;
List5.Duplicates := <i>dupError</i>; // Compliant
        ]]>
    </example>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.LowerCaseReservedWordsRule"
        message="Keywords should be lowercase"
        name="LowerCaseReservedWordsRule">
    <priority>3</priority>
    <description>
      Reserved keywords should always be lowercase.
      &lt;br&gt;
      &lt;br&gt;
    </description>
    <properties>
      <property name="baseEffort" value="1min" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.XPathTemplateRule"
    message="Track breaches of an XPath rule"
    name="XPathRule">
    <priority>3</priority>
    <description>Track breaches of an XPath rule</description>
    <properties>
      <property name="baseEffort" value="5min" />
      <property name="template" value="true" />
      <property name="xpath" />
      <property name="message" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.CommentRegexRule"
    message="Track comments matching a regular expression"
    name="CommentRegexRule">
    <priority>3</priority>
    <description>
      This rule template can be used to create rules which will be triggered when the full content
      of a comment matches a given regular expression.
      Note that the regular expression should be expressed using the dotall format
      (where the &lt;code&gt;.&lt;/code&gt; character matches any character).
      &lt;br&gt;
      &lt;br&gt;
      For example, one can create a rule with the regular expression &lt;code&gt;.*REVIEW.*&lt;/code&gt; to match all
      comments containing "REVIEW".
      &lt;br&gt;
      &lt;br&gt;
      Note that, in order to match REVIEW regardless of the case, the &lt;code&gt;(?i)&lt;/code&gt; modifier should be
      prepended to the expression, as in &lt;code&gt;(?i).*REVIEW.*&lt;/code&gt;.
    </description>
    <properties>
      <property name="baseEffort" value="20min" />
      <property name="template" value="true" />
      <property name="regex" />
      <property name="message" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.StringLiteralRegexRule"
    message="Track string literals matching a regular expression"
    name="StringLiteralRegexRule">
    <priority>3</priority>
    <description>
      This rule template can be used to create rules which will be triggered when the full content
      of a string literal matches a given regular expression.
      Note that the regular expression should be expressed using the dotall format
      (where the &lt;code&gt;.&lt;/code&gt; character matches any character).
      &lt;br&gt;
      &lt;br&gt;
      For example, one can create a rule with the regular expression &lt;code&gt;.*REVIEW.*&lt;/code&gt; to match all
      strings containing "REVIEW".
      &lt;br&gt;
      &lt;br&gt;
      Note that, in order to match REVIEW regardless of the case, the &lt;code&gt;(?i)&lt;/code&gt; modifier should be
      prepended to the expression, as in &lt;code&gt;(?i).*REVIEW.*&lt;/code&gt;.
    </description>
    <properties>
      <property name="baseEffort" value="20min" />
      <property name="template" value="true" />
      <property name="scope" value="MAIN" />
      <property name="regex" />
      <property name="message" />
    </properties>
  </rule>

  <rule class="org.sonar.plugins.delphi.pmd.rules.InheritedTypeNameRule"
    message="Types which inherit from some other specified type should comply with a naming convention"
    name="InheritedTypeNameRule">
    <priority>3</priority>
    <description>
      This rule template can be used to enforce naming convention on a type which inherits from some other type.
      &lt;br&gt;
      Please note that this only supports direct inheritance and does not traverse the inheritance tree.
    </description>
    <properties>
      <property name="baseEffort" value="1min" />
      <property name="template" value="true" />
      <property name="nameRegex" />
      <property name="parentNameRegex" />
      <property name="message" />
    </properties>
  </rule>
</ruleset>
